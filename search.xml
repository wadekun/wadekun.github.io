<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>风控系统</title>
      <link href="/2022/12/13/%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/12/13/%E9%A3%8E%E6%8E%A7%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>时间过的好快，转眼博客已停更4年多，草已三米高矣。最近经历了挺多事，其中酸楚难以言表。前司也刚刚倒闭，那段时间做的一些项目也是一笔不小的知识财富，想想当时如果把自己产出的文档和代码保存下来，到现在也不算侵权了吧哈哈。既然如此，现在试着整理整理以前做过的一些觉得很有意思的项目，温故而知新。</p><p>就从风控系统开始吧。</p><span id="more"></span><!-- 需求场景 --><p>前公司是一家购药服务平台，对C端用户提供购药服务，售药服务主要是各大连锁提供。平台为提高流量会经常有一些优惠活动。这就给了一些黄牛、甚至连锁内部店员一些薅羊毛的机会。所以最开始，运营给的需求很简单，给出了一些固定的规则，比如每人每天限购多少单，最高上限订单金额为多少。然后提供了一批黑名单顾客，如果在该名单内的顾客限制登录等，且当时由于有正在进行中的一些优惠活动，运营希望需求尽早上线。</p><!-- 最开始的实现方案：case by case --><!-- 遇到的问题 --><p>所以为了快速响应需求，且由于需求较为简单，最早采用了case by case，硬编码的方式将需求实现了。然而很快，一波接一波新的需求又接踵而至，而且复杂度也越来越高，比如近x小时内，在某名单内的用户，购买某类型的商品超过y单，则禁止购买下单z小时等。而且这里的x、y、z的值也是随着不同的业务需求而频繁的更改，于是简单的case by case的硬编码方式已经无法满足业务的需求了。迫切的需要一个能够及时响应规则变更，实时计算风控指标，满足业务多种多样的风控规则的风控系统。</p><!-- 风控4.0 --><h2 id="用例视图："><a href="#用例视图：" class="headerlink" title="用例视图："></a>用例视图：</h2><p><img src="/images/riskcontrol_user_case.png" alt="用例视图"></p><p>系统的用户角色有两种：业务系统和产品运营。</p><ul><li>业务系统可以通过resultful接入风控系统，传入当前风控事件，获得风控规则验证结果。也可以通过消息中间件实时上报业务事件进行指标数据计算。</li><li>产品运营可以通过运营平台维护风控规则，查看风控日志等。</li></ul><h2 id="逻辑视图"><a href="#逻辑视图" class="headerlink" title="逻辑视图"></a>逻辑视图</h2><p><img src="/images/riskcontrol_logic_arch.png" alt="逻辑视图"></p><p>整个风控系统分为三个层：接入层，核心服务层，数据存储层。</p><ul><li>接入层对外提供接入风控系统的规范，同时进行参数校验、权限校验、服务限流等功能。该层屏蔽了风控系统的核心逻辑，对外提供简单、规范、易用的接入接口。</li><li>核心服务层是风控系统的核心，主要进行风控规则的维护，以及基于业务主动（kafka消息）、被动（binlog）上报的业务事件及运营维护的风控规则进行风控指标的计算。以及根据风控校验入参进行风险事件判断。</li><li>数据存储层存储风控系统的核心数据，包括业务系统上报的业务事件数据、实时&#x2F;离线计算的指标数据、名单库、规则库、报表、日志等。风控系统数据计算逻辑复杂，涉及数据量大（日接入数据量千万级，当然跟大厂比起来毛毛雨了哈哈），所以数据的存储设计非常重要，有位大牛曾经说过数据结构和算法决定了系统的性能上限，应用代码只是逼近这个上线而已。</li></ul><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><p>有了系统逻辑架构的指导之后开始进行相应组件的技术选型。</p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><ol><li>对于配置类数据和名单库数据，数据量小，逻辑较为复杂，尤其是风控规则，会有一对多、多对多的关系，且变更较为频繁，所以还是采用传统的关系型数据库Mysql来存储。</li><li>对于指标数据，因为维度很多，数据量较大，且更新查询频繁，写多读更多，比较适合使用key-value数据库存储。根据使用场景决定采用Redis来存储实时指标数据，Hbase来存储离线指标数据。</li><li>报表数据是离线或实时计算出的统计数据，数据量相对较小，且逻辑较为简单，暂时采用Mysql来存储。</li></ol><h3 id="数据计算"><a href="#数据计算" class="headerlink" title="数据计算"></a>数据计算</h3><p>在核心服务内会有针对实时业务事件根据配置的风控规则进行数据计算的场景，数据计算分两种形式：实时和离线。实时计算是通过消息队列接受业务系统实时上报的业务数据（如订单中心上报的实时订单数据）进行计算。离线计算则是需要拉取业务的存量数据进行计算。风控数据计算逻辑都较为复杂，考虑到服务的可靠性、可扩展性、以及尽量减少开发中的重复工作，所以还是采用业界常用的开源组件。</p><ol><li>实时计算，业界目前比较火的就是Apache Flink和Apache Spark了，两个计算框架都是很活跃很优秀的实时计算框架。都可以满足我们的需求，但是Spark和Flink在实时计算还是还是有一些差别，Flink的设计之初就是为了实时流计算，把批处理当做有界的数据流。而Spark的实时流处理是秒级别的微批处理。所以在实时性上相比于Flink还是稍逊一筹（不过Spark自2.3之后推出了 <code>Continuous Processing</code>，可以实现端到端毫秒级别的延迟，不过目前状态还是Experimental）<a href="#ref-anchor"><sup>1</sup></a>。基于风控场景的严肃性（毕竟是为了控制风险，时间就是金钱哈哈），我们最终选择Flink作为我们的实时计算引擎。</li><li>离线计算，主要是针对业务系统的存量数据进行计算，实时性要求不高，所以使用Hive&#x2F;Spark&#x2F;Flink混用，因为大数据平台这些组件都已经提供了，大家根据各自的技能熟练度开发，并不做强制要求。</li></ol><h3 id="规则引擎"><a href="#规则引擎" class="headerlink" title="规则引擎"></a>规则引擎</h3><p>规则引擎是风控系统的核心组件，主要的职责是运营配置规则的执行功能。主要的执行逻辑如图：<br><img src="/images/riskcontrol_ruleengine_logic.png"></p><p>执行流程虽然简单，但是却封装了系统最复杂的规则抽象与规则计算。什么是风控规则？我们对风控规则的定义是一组定义好的，用于分析和判断当前用户行为，识别潜在的风险和异常情况的逻辑规则。直观点从开发者的角度，用伪代码描述，一条规则可以是一组<code>if-else</code>条件判断语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (test_case1) then doAction1</span><br><span class="line">elif (test_case2) then doAction2</span><br><span class="line">else doAction3</span><br></pre></td></tr></table></figure><p>其中<code>test_case</code>是一条条件判断语句，如<code>（expression1）&amp;&amp; ((expression2) || (expression3)）</code>。<br>条件判断语句中<code>expression</code>是一条原子判断表达式，如在<code>用户在黑名单中</code>、<code>近1小时订单数大于3</code>等等，表达式的值为可以判断真假的<code>boolean</code>。<br>其中<code>用户在黑名单中</code>需要用到当前的判断主体中黑名单相关的属性去判断，比如我们的黑名单是存储的用户id，那就要用到当前用户的id，这个id成为用户的基础属性，可以被归类为静态属性。<code>近1小时的订单数大于3</code>需要用到当前用户的<code>近1小时的订单数</code>，这个订单数就是指标数据，可以被归类为动态属性，动态是需要实时或离线计算的。指标计算牵扯到实时、离线计算。（关于数据计算，数据如何存储，如何保证实时事件消费的精确一次（Exactly-Once），这又是一个比较大的话题，可以再写篇文章好好聊一下。）在对指标进行抽象设计之后，我们又对指标分组，允许运营基于多条指标配置成一条规则组，然后再配置到对应场景（如下单、支付、登录等）。如此完成业务配置到底层抽象规则之间的映射。</p><p>在做完风控规则体系的抽象设计之后，就要开始进行底层实现的技术选型了，由于研发资源有限，业务需求紧迫，所以还是首先调研市场上现有的规则引擎相关的组件，主要包括了：Flink CEP、Drools、Groovy、AviatorScript。<br>其中Flink CEP（Complex Event Processing）就是为了应对复杂事件处理的库。处理事件的规则，被叫做“模式”(Pattern)，Flink CEP 提供了 Pattern API，用于对输入流数据进行 复杂事件规则定义，用来提取符合规则的事件序列。但是Flink CEP不支持规则实时更新，目前官方给的例子也只是从数据库中定时轮训。而且我们当时的风控规则比较复杂，而且大多数都是依赖统计聚合的指标数据，所以想要把我们的规则完全基于Flink CEP实现有很比较大的难度。<br>Drools是用java开发的业界比较成熟的规则引擎。内置的Drools Fusion也提供了CEP的功能。功能比较完善，还有系统监控、操作平台。但是Drools的规则语言比较复杂，随着业务迭代，维护这些大量的规则也是件比较痛苦的事。而且以内存实现时间窗功能，无法支持较长跨度的时间窗。我们的规则经常有近X天、近X周甚至近三个月这样的时间跨度。<br>Groovy是JVM上的动态语言，有完善的语言特性，支持面向对象编程、闭包、元编程等高级特性，还有grovvy-sql模块提供了对数据库访问的支持。AviatorScript是一个高性能的脚本语言，支持数字、字符串、正则表达式、布尔值、正则表达式等基本类型，完整支持所有 Java 运算符及优先级等相比于Groovy，它轻了不少，可以看做是Groovy的子集。<br>经过对比，我们最终决定基于AviatorScript实现我们的风控规则引擎。</p><h2 id="可靠性、可扩展性与可维护性"><a href="#可靠性、可扩展性与可维护性" class="headerlink" title="可靠性、可扩展性与可维护性"></a>可靠性、可扩展性与可维护性</h2><p>这里参考<a href="https://book.douban.com/subject/30329536/comments/">数据密集型应用系统设计</a>，从可靠性、可扩展性与可维护性三个角度来描述风控系统的非功能性需求的设计。可靠性、可扩展性与可维护性是系统设计时就要考虑的几个基本问题。</p><ul><li>可靠性是系统应对故障的能力。故障包括<code>硬件故障</code>、<code>软件错误</code>、<code>人为错误</code>。</li><li>可扩展性是系统应对系统负载增长的能力（如数据量、流量、复杂性）。</li><li>可维护性，有时候与上线一个系统相比，如何持续的维护好一个系统，比如应对新的需求变化、修复漏洞、对系统的运行状态有更全面真实的感知。</li></ul><h3 id="可靠性与可用性"><a href="#可靠性与可用性" class="headerlink" title="可靠性与可用性"></a>可靠性与可用性</h3><blockquote><p>说起可靠性（Reliability），还有一个比较容易混淆的词，那就是可用性（Availability）。虽然都是描述系统能够提供高质量服务的能力。但是在衡量标准上还是有一些区别的。可用性（Availability）关注的是系统的提供服务的总体持续时间，给定的时间内总体的运行时间越长，可用性越高，比如一个系统一年宕机8.76小时，那么他的可用性就是99.9%。<br>而可靠性（Reliability）关注的是系统可以无故障地持续运行的时间，可靠性相关的几个关键指标：</p><ul><li>MTTF（Mean Time To Failure）<br>  即平均无故障时间，是指从新的产品在规定的工作环境条件下开始工作到出现第一个故障的时间的平均值。MTBF越长表示可靠性越高，正确工作能力越强 。</li><li>MTTR（Mean Time To Repair）<br>  即平均修复时间，是指可修复产品的平均修复时间，就是从出现故障到修复中间的这段时间。MTTR越短表示易恢复性越好。</li></ul></blockquote><blockquote><p>提高可靠性最常用的办法就是冗余并且实现故障转移（Failover）。</p></blockquote><ul><li>接入层应用是无状态的SpringBoot微服务，是以容器的方式部署在k8s集群上，通过nginx进行反向代理并实现负载均衡。接入层应用需要查询数据库，部分接口涉及到一些统计数据的查询，是服务瓶颈点，高峰期做了限流处理。目前部署两个实例，单个实例可支持2000+TPS，实际上我们生产环境最高TPS为200左右。</li><li>核心服务层最重要的组件规则引擎目前涉及到指标查询及规则计算。目前指标数据都已缓存在内存数据库redis中，网络IO也基本查询redis。规则引擎也是Java的SpringBoot项目，也是以容器的方式部署在k8s集群上，高峰期做了动态扩容。</li><li>MQ我们是使用的Kafka，集群目前3个broker。我们没有对kakfa做性能测试，根据官方的性能描述文章<a href="#ref-anchor"><sup>2</sup></a>，在3台普通的服务器上，可达到200万每秒的写入，这完全满足我们的生产需要（我们生产环境最高的消息写入量级是十万每秒）。</li></ul><h2 id="成果、不足和展望"><a href="#成果、不足和展望" class="headerlink" title="成果、不足和展望"></a>成果、不足和展望</h2><p>对风控系统做了本次重构之后，风控系统满足了运营的业务需求，可以支持规则的快速配置与实时生效，上线后半年时间累计挽回公司损失数千万。但是还是停留在人工配置的阶段，没有最大化利用数据的价值，我们期望以后可以加入算法模块，实现事前的风险预警，弥补人工对风险感知的滞后性。</p><h2 id="最终架构"><a href="#最终架构" class="headerlink" title="最终架构"></a>最终架构</h2><!-- 业务架构：不考虑用什么技术、什么组件，着重对业务边界的划分。列出系统中的一些模块--><!-- 应用架构：划分出系统的层级，每个层级的组成服务。类似于网络分层协议，每一层都是对底层实现的封装，上一层是基于底层协议对外提供相应的功能接口 --><!-- 数据架构：系统涉及的数据以及数据流向 --><!-- 技术架构：技术选型。 --><p><img src="/images/riskcontrol-arch.png"></p><div id="ref-anchor"></div><h2 id="Refrences"><a href="#Refrences" class="headerlink" title="Refrences"></a>Refrences</h2><p>[1] <a href="https://spark.apache.org/docs/latest/structured-streaming-programming-guide.html#overview">Spark Overview</a><br>[2] <a href="https://kafka.apache.org/performance.html">Apache Kafka PERFORMANCE</a><br>[3] [Benchmarking Apache Kafka: 2 Million Writes Per Second (On Three Cheap Machines)] (<a href="https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines">https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> 风控 </tag>
            
            <tag> 实时计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java AQS详解</title>
      <link href="/2018/02/24/Java-AQS%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/02/24/Java-AQS%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><code>AbstractQueuedSynchronizer</code>抽象队列同步器，定义了一套多线程访问共享资源的同步器框架，Java中许多同步工具类都依赖于它，如常用的<code>ReentrantLock/Semaphore/CountDownLatch</code>。</p><span id="more"></span><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>图片来自 <a href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></p><p><img src="/images/aqs_framework.png"></p><p><code>AQS</code>维护了一个<code>volatile int state</code>变量（代表共享资源）。和一个<code>FIFO</code>队列(CLH队列)，多线程争用资源被阻塞时会进入此队列。</p><p><code>state</code>的三个操作： </p><ul><li><code>getState()</code></li><li><code>setState()</code></li><li><code>compareAndSetState()</code></li></ul><p>AQS定义资源有两种使用方式：Exclusive（独占，当前时刻只能一个线程运行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore、CountDownLatch）。<br>不同的自定义同步器争用共享资源的方式也不同。<strong>自定义同步器只要实现资源state的获取和释放即可</strong>，至于线程等待队列的维护（线程获取资源失败后 阻塞入队、唤醒出队等）AQS已经实现好了。自定义同步器实现时主要实现以下几个方法：</p><ol><li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到<code>condition</code>才需要去实现它。</li><li><code>tryAcquire(int)</code>：独占方式，尝试获取资源。成功返回<code>true</code>，失败返回<code>false</code>。</li><li><code>tryRelease(int)</code>：独占方式，尝试释放资源。成功返回<code>true</code>，失败返回<code>false</code>。</li><li><code>tryAcquireShared(int)</code>：共享方式尝试获取资源。负数表示失败。0表示成功，但没有可用资源。整数表示成功，且有剩余资源。</li><li><code>tryReleaseShared(int)</code>：共享方式尝试释放资源。如果释放后允许唤醒后续等待节点返回<code>true</code>，否则返回<code>false</code>。</li></ol><p>独占模式以<code>ReentrantLock</code>为例。<code>state</code>初始化为0。A线程<code>lock</code>时，调用<code>tryAcquire(1)</code>获取资源资源，获取成功，state值为1。此时，其他线程尝试获取资源就会失败。只有当A线程<code>unlock</code>时，调用<code>tryRelease(1)</code>释放资源。在<code>ReentrantLock</code>中，线程A可以使用<code>tryAcquire()</code>重复获取资源，当然每次<code>tryAcquire</code>必须通过一次<code>tryRelease</code>来释放。只有当<code>state == 0</code>时，其他线程才可以获取资源。</p><p>共享模式以<code>CountDownLatch</code>为例。构造方法<code>CountDownLatch(int count)</code>，初始化state为指定值count，每个业务线程在执行到指定位置时，调用<code>countDown()</code>方法释放资源，当<code>state</code>值置为<code>0</code>时，<code>await</code>线程被唤醒(unpark)。</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="acquire-int-arg"><a href="#acquire-int-arg" class="headerlink" title="acquire(int arg)"></a>acquire(int arg)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>函数流程如下：</p><ol><li><code>tryAcquire()</code> 尝试获取资源，如果成功则返回。</li><li><code>addWaiter(Node.EXCLUSIVE)</code> 将该线程加入等待队列的尾部，并标记为独占模式。并返回添加的节点。</li><li><code>acquireQueued()</code> 使线程在队列中获取资源，一直获取到资源后再返回。如果整个等待过程中被中断过则返回<code>true</code>，否则返回<code>false</code>。</li><li><code>selfInterrupt()</code> 如果线程在等待的过程中被中断过，它是不响应的。只有获取资源后再进行自我中断<code>selfInterrupt()</code>，将中断补上。</li></ol><h3 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模板方法<code>acquire</code>中，<code>tryAcquire</code>就是由子类去实现的操作（通过state的get&#x2F;set&#x2F;CAS）。至于能不能重入，能不能加塞，就看自定义的同步器怎么去设计了。</p><p>这里之所以设计成<code>protected</code>而没有设计成<code>abstract</code>，是因为独占模式下只需实现<code>tryAcquire-tryRelease</code>，共享模式下只需实现<code>tryAcquireShared-tryReleaseShared</code>。如果都设计成<code>abstract</code>的，那么每个自定义同步器都需要自己去实现一遍。所以，这也减少了不必要的工作量。</p><h3 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h3><p>该方法将当前线程加入等待队列的队尾，并返回当前线程所在的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 以给定模式创建节点，mode有两种：EXCLUSIVE（独占），SHARED（共享）</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123; <span class="comment">// 通过cas操作，快速入队至队尾</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node); <span class="comment">// 如果快速入队失败，则调用enq方法入队</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enq-Node"><a href="#enq-Node" class="headerlink" title="enq(Node)"></a>enq(Node)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize （如果队列为空，则初始化一个头节点，尾指针也指向它）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 走入队流程，当前节点将前驱指向尾节点，并cas操作将当前节点置为尾节点（尾节点指向当前节点）</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued()"></a>acquireQueued()</h3><p>经过<code>tryAcquire</code>和<code>addWaiter</code>当前线程已经获取锁（资源）失败进入等待队列中了。接着就是进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以开始自己的表演了（这个过程是不可中断的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">* queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 中断标记</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor(); <span class="comment">// 前驱节点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果前驱节点是头节点，那么再次尝试获取资源</span></span><br><span class="line">            <span class="comment">// 进行到这一步，可能是初次入队，也可能是前驱节点释放完资源唤醒自己，也可能是被interrupt了</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; </span><br><span class="line">                setHead(node); <span class="comment">// 如果获取成功，表名前驱节点已经执行完毕彻底释放资源，将当前节点置为头节点</span></span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted; <span class="comment">// 返回等待过程中是否被中断过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// shouldParkAfterFailedAcquire 检查当前线程是否应该休息</span></span><br><span class="line">            <span class="comment">// parkAndCheckInterrupt 当前线程休眠并检查中断状态</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>; <span class="comment">// 如果当前线程曾被中断，则设置中断标记为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shouldParkAfterFailedAcquire-Node-Node"><a href="#shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="shouldParkAfterFailedAcquire(Node, Node)"></a>shouldParkAfterFailedAcquire(Node, Node)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">* Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">* control in all acquire loops.  Requires that pred == node.prev.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment">*/</span>          </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;  <span class="comment">// 前驱节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) <span class="comment">// 如果状态为SIGNAL(-1)，表名前驱释放资源后会通知(unpark)自己，则可以安心休息，直接返回true</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">            * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// 如果状态大于0，则表名前驱已经放弃(CANCEL)，一直往前找，找到最近的一个未放弃的节点，排在它后面</span></span><br><span class="line">        <span class="comment">// 中间跳过的节点将被回收掉(GC)</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">            * indicate retry.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 状态为0(未设置过等待状态)或-2时，将状态设置为SIGNAL。即 释放资源后通知下自己</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">            * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">            * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程中，如果前驱不为SIGNAL，则需要跳过那些状态值大于0(CANCEL)的节点，链到状态值小于0的节点后，并将新的前驱状态值设置为SIGNAL。<br>总之就是保证前驱的状态为SIGNAL，才能放心的去休息。</p><h4 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>); <span class="comment">// 调用 park() 使线程进入waiting状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted(); <span class="comment">// 如果被唤醒，则检查自己是否被中断过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>park()</code>会让线程进入<code>waiting</code>状态，这个状态下的线程有两种途径可以唤醒：1) 被unpark()，2) 被interrupt()。<br>Thread.interrupted()会检查当前的终端状态，并将中断状态清除。</p><h2 id="acquire-int-arg-小结"><a href="#acquire-int-arg-小结" class="headerlink" title="acquire(int arg) 小结"></a>acquire(int arg) 小结</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">* by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">* returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">* repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">* to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">*        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">*        can represent anything you like.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再总结下<code>acquire</code>的流程：</p><ol><li>通过<code>tryAcquire</code>尝试获取资源，如果成功则直接返回</li><li>如果上一步资源没有获取成功，则调用<code>addWaiter</code>将当前线程以独占模式加入等待队列尾部</li><li>加入队列成功后，<code>acquireQueued</code>方法使线程找到安全点（确保前驱节点状态不为CANCEL），并设置前驱节点拿到资源后唤醒自己。调用<code>park</code>进入休眠。在被前驱节点<code>unpark</code>或被<code>interrupt</code>后再次尝试获取资源。在这个过程中如果被中断或则记录中断状态，不响应中断。</li><li>如果在线程park过程中被中断过，则在获取到资源后调用<code>selfInterrupt</code>将中断补上。</li></ol><p><img src="/images/aqs-acquire-flow.png"></p><h2 id="release-int-arg"><a href="#release-int-arg" class="headerlink" title="release(int arg)"></a>release(int arg)</h2><p>该方法是释放共享资源的顶层入口。它会释放指定量的资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">     * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">     * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="tryRelease-int"><a href="#tryRelease-int" class="headerlink" title="tryRelease(int)"></a>tryRelease(int)</h3><p>这同<code>tryAcquire(int)</code>一样是需要子类去实现的方法。<code>release(int)</code>通过<code>tryRelease(int)</code>的返回结果来判断资源是否成功释放。在自定义同步器时，如果资源已经彻底释放掉(state &#x3D;&#x3D; 0)则返回<code>true</code>，否则(state !&#x3D; 0)返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unparkSuccessor-Node"><a href="#unparkSuccessor-Node" class="headerlink" title="unparkSuccessor(Node)"></a>unparkSuccessor(Node)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 置零当前线程所在的节点状态</span></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果当前节点的后继节点为空或者为已取消</span></span><br><span class="line">            s = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 则从尾节点向前遍历找到最前面的可用节点</span></span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">// 等待状态 &lt;=0 的节点都是有效节点</span></span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="literal">null</span>) </span><br><span class="line">            LockSupport.unpark(s.thread); <span class="comment">// 唤醒该节点</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数要做的就是 <strong>唤醒最前面的那个未放弃（CANCEL）的节点</strong>。假设该节点为s，则s被唤醒，s进入<code>acquireQueued</code>中<code>final Node p = node.predecessor(); p == head &amp;&amp; tryAcquire(arg)</code>的判断，如果此时，s的前驱节点为head节点，则尝试获取资源。如果<code>p != head</code>则进入<code>shouldParkAfterFailedAcquire</code>的调整，s也必然会跑到<code>head</code>节点的next节点，然后自旋成功，通过<code>tryAcquire</code>成功获取到资源，并且通过<code>setHead()</code>将自己设置成head节点。<code>acquire</code>函数返回，获取资源(锁)成功，进行接下来的操作。</p><h3 id="unparkSuccessor的疑问"><a href="#unparkSuccessor的疑问" class="headerlink" title="unparkSuccessor的疑问"></a>unparkSuccessor的疑问</h3><p>这里对于<code>unparkSuccessor</code>为何从后向前遍历有个疑问。 <a href="https://www.zhihu.com/question/50724462">Java AQS unparkSuccessor 方法中for循环从tail开始而不是head的疑问？</a></p><p>看<code>addWaiter(Node)</code>入队操作：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由代码可以看出，先将新节点node.prev指向尾节点t，而通过CAS操作<code>compareAndSetTail(t, node)</code>保证了前一步的线程安全，因为CAS失败则进入下一轮循环，CAS成功后再由t.next指向新的节点。所以如果从前向后遍历的话，可能是找不到这个新节点的（t.next &#x3D; node未执行）。</p><h2 id="acquireShared-int-arg"><a href="#acquireShared-int-arg" class="headerlink" title="acquireShared(int arg)"></a>acquireShared(int arg)</h2><p>该方法是共享模式下获取共享资源的顶层模板方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment">* first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment">* returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">* repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">* #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">*        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">*        and can represent anything you like.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) </span><br><span class="line">        doAcquireShared(arg); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>tryAcquireShared</code>也需要由自定义同步器去实现。但是AQS已经把<code>tryAcquireShared</code>的返回值语义定义好了：</p><ul><li>0：获取成功，但没有剩余资源</li><li>正数：获取成功，还有剩余资源，其他线程还可以继续获取</li><li>负数：获取失败</li></ul><p>SO，这里<code>acquireShared</code>的获取流程是：</p><ol><li><code>tryAcquireShared</code>获取资源，成功则直接返回</li><li>失败则通过<code>doAcquireShared</code>进入等待队列，直至获取资源成功返回。</li></ol><h3 id="tryAcquireShared-int"><a href="#tryAcquireShared-int" class="headerlink" title="tryAcquireShared(int)"></a>tryAcquireShared(int)</h3><p>与<code>tryAcquire</code>一样，<code>tryAcquireShared</code>也被设计成由子类实现的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doAcquireShared-int"><a href="#doAcquireShared-int" class="headerlink" title="doAcquireShared(int)"></a>doAcquireShared(int)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED); <span class="comment">// 加入队列尾部</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 失败标志</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 是否被中断过标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor(); <span class="comment">// 当前节点的前驱节点（此时可能是被前驱节点unpark）</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 如果前驱节点是head节点（head节点释放资源后通知自己）</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg); <span class="comment">// 尝试获取资源</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 获取资源成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r); <span class="comment">// 当前节点置为头节点，并根据是否有剩余资源决定唤醒后面的线程</span></span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted) <span class="comment">// 如果被中断过，补上中断</span></span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1. shouldParkAfterFailedAcquire 判断是否需要休息</span></span><br><span class="line">            <span class="comment">// 2. parkAndCheckInterrupt park当前线程，并检查是否有中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有木有觉得跟acquireQueued()很相似？对，其实流程并没有太大区别。只不过这里将补中断的selfInterrupt()放到doAcquireShared()里了，而独占模式是放到acquireQueued()之外，其实都一样，不知道Doug Lea是怎么想的。</p></blockquote><blockquote><p>跟独占模式比，还有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p></blockquote><h3 id="setHeadAndPropagate-Node-int"><a href="#setHeadAndPropagate-Node-int" class="headerlink" title="setHeadAndPropagate(Node, int)"></a>setHeadAndPropagate(Node, int)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment">* in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment">* PROPAGATE status was set.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">        *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">        *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">        *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">        *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">        *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">        * and</span></span><br><span class="line"><span class="comment">        *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">        *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">        * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">        * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">        * anyway.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果还有剩余量，则唤醒后继线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="releaseShared-int-arg"><a href="#releaseShared-int-arg" class="headerlink" title="releaseShared(int arg)"></a>releaseShared(int arg)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Releases in shared mode.  Implemented by unblocking one or more</span></span><br><span class="line"><span class="comment">* threads if &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; returns true.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">*        &#123;<span class="doctag">@link</span> #tryReleaseShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">*        and can represent anything you like.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryReleaseShared&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123; <span class="comment">// 尝试释放资源</span></span><br><span class="line">        doReleaseShared(); <span class="comment">// 唤醒后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state&#x3D;0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state&#x3D;0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p></blockquote><h3 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared"></a>doReleaseShared</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Release action for shared mode -- signals successor and ensures</span></span><br><span class="line"><span class="comment">* propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">* to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">        * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">        * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">        * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">        * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">        * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">        * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">        * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">        * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h); <span class="comment">// 唤醒后继</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h1><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><ul><li>isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/waterystone/p/4920797.html">http://www.cnblogs.com/waterystone/p/4920797.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java - 并发编程 - 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老兵不死，只会慢慢凋零</title>
      <link href="/2017/05/21/%E8%80%81%E5%85%B5%E4%B8%8D%E6%AD%BB%EF%BC%8C%E5%8F%AA%E4%BC%9A%E6%85%A2%E6%85%A2%E5%87%8B%E9%9B%B6/"/>
      <url>/2017/05/21/%E8%80%81%E5%85%B5%E4%B8%8D%E6%AD%BB%EF%BC%8C%E5%8F%AA%E4%BC%9A%E6%85%A2%E6%85%A2%E5%87%8B%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<p>…嵌的iframe好像在github上显示不了啊，直接地址复制看源视频吧，今天看了马刺和勇士的G3，CCTV5的视频做的很不错，有感而发。</p><p>正版的 Battle Symphony 版权保护，生成不了链接…囧</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100" height="5" src="//music.163.com/outchain/player?type=2&id=466299780&auto=1&height=66"></iframe><p><strong>老兵不死，只会慢慢凋零…</strong></p><span id="more"></span><p><a href="http://player.cntv.cn/flashplayer/players/htmls/smallwindow.html?pid=5b79131e00b242d6b4a9acf2d4627374&time=60.734&tai=news">http://player.cntv.cn/flashplayer/players/htmls/smallwindow.html?pid=5b79131e00b242d6b4a9acf2d4627374&amp;time=60.734&amp;tai=news</a></p><iframe src="http://player.cntv.cn/flashplayer/players/htmls/smallwindow.html?pid=5b79131e00b242d6b4a9acf2d4627374&time=60.734&tai=news" width="700px" height="500px"><iframe>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 篮球 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程知识整理</title>
      <link href="/2017/02/17/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2017/02/17/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>大致整理下Java并发编程相关的知识点。</p><p>一本书可以越读越厚，也可以越读越薄。</p><span id="more"></span><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol><li><p>线程安全    </p><blockquote><p>当多个线程访问某个类时，不管按此用何种调度方式，并且在主调代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p></blockquote></li><li><p>可见性    </p><blockquote><p>一个线程对内存的修改可以被其他线程感知。</p></blockquote></li><li><p>竞态条件   </p><blockquote><p>在并发编程中，由于不恰当的执行时序而出现不正确的结果的情况称为为竞态条件（或者说对线程的执行顺序敏感，不同的执行顺序会出现不同的值，从而出现不可预知的情况）。</p></blockquote></li></ol><h1 id="基础构建模块"><a href="#基础构建模块" class="headerlink" title="基础构建模块"></a>基础构建模块</h1><p>jdk中封装了一些多线程工具类，供开发者开发线程安全的系统。</p><p>这些工具包括：   </p><ul><li>同步容器：所有的操作都是同步(synchronized)的</li><li>并发容器：提供了高效的线程安全的符合操作API</li><li>同步工具：用于线程之间的协调操作</li></ul><h2 id="同步容器类"><a href="#同步容器类" class="headerlink" title="同步容器类"></a>同步容器类</h2><ul><li>Vector</li><li>HashTable</li></ul><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><ul><li>CurrentHashMap 并发HashMap</li><li>CopyOnWriteArrayList</li><li>Queue<ul><li>ConcurrentLinkedQueue 并发队列链表实现</li><li>BlockingQueue 阻塞队列，可用于构建消费者生产者模式（take&#x2F;put）</li></ul></li></ul><h2 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h2><ul><li>CountDownLatch 闭锁，等待某一组条件发生(countDown&#x2F;await)</li><li>Semaphore 信号量，空着操作某个资源的线程数量(acquire&#x2F;release)</li><li>CyclicBarrier 栅栏，所有线程到达同一位置，可重置（await&#x2F;reset）</li></ul><h1 id="并发任务执行"><a href="#并发任务执行" class="headerlink" title="并发任务执行"></a>并发任务执行</h1><p>在并发执行任务的场景中，通常需要创建大量的线程去并发执行这些任务。无限制创建线程可能带来的问题：    </p><ul><li>线程生命周期的开销非常高</li><li>资源消耗<br>活跃的线程会消耗系统资源，尤其是内存。如果可运行的线程数量多于可用处理器的数量，那么有些线程会闲置。大量的空闲线程会占用许多内存，给垃圾收集器带来压力，并且大量线程竞争CPU资源时还将产生其他的性能开销。此时无限制的的创建线程反而会降低性能。   </li><li>稳定性<br>无限制的创建线程可能导致OOM。</li></ul><h2 id="Executor框架与线程池"><a href="#Executor框架与线程池" class="headerlink" title="Executor框架与线程池"></a>Executor框架与线程池</h2><p>为了避免无限制创建线程所带来的问题，Java提供了Executor框架，来并发执行异步任务。<br><img src="http://ww1.sinaimg.cn/large/a1d44fefgy1fdcxsi1w3jj20d40i4js9"><br><img src="http://ww1.sinaimg.cn/large/a1d44fefgy1fdcz6ysx0fj21ae0tgjxi"></p><p><code>Executor</code>允许你指定自己的任务执行策略，包括：</p><ul><li>在什么（What）线程中执行任务？（ThreadFactory）</li><li>任务按照什么（What）顺序（FIFO、LIFO、优先级）执行？</li><li>在队列中有多少个（How Many）任务在等待执行？</li><li>如果系统由于过载而需要拒绝一个任务，那么应该选择哪一个（Which）任务</li></ul><p>可以通过<code>Executors</code>的静态方法，创建不同策略的<code>Executor</code><br><img src="http://ww1.sinaimg.cn/large/a1d44fefly1fdczh36cauj20vu0cun0e"></p><h2 id="任务取消与关闭"><a href="#任务取消与关闭" class="headerlink" title="任务取消与关闭"></a>任务取消与关闭</h2><p>通常会遇到提前结束正在执行的任务，例如用户取消操作，应用提前关闭等。Java没有提供任何机制来安全的关闭线程。<br><code>Thread.stop</code>与<code>Thread.suspend</code>提供了这样的机制，但却有缺陷。<code>Thread.stop</code>会抛出一个<code>ThreadDeath</code>错误，导致当前线程被立即停止，当前线程持有的锁所保护的状态变量此时可能处于不一致的状态，而对其他线程可见，造成不可预知的线程安全问题。<code>Thread.suspend</code>与<code>Thread.resume</code>配合使用时，很容易造成死锁，<code>Thread.suspend</code>的线程被终止前如果持有一个锁，而调用<code>Thread.resume</code>试图恢复该线程的线程如果正在尝试获取这个锁，那么将发生死锁。</p><p>可以使用线程的中断机制来实现线程的优雅停止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Thread &#123;</span><br><span class="line">  // 中断当前线程，设置中断状态</span><br><span class="line">  public void interrupt() &#123;&#125;</span><br><span class="line">  // 检测当前线程是否被中断</span><br><span class="line">  public void isInterrupted() &#123;&#125;</span><br><span class="line">  // 检测当前的中断状态，如果被中断，则重置中断状态为未中断  </span><br><span class="line">  public static boolean interrupted() &#123;&#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- # 高级主题 --><!-- ## 显示锁 -->]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解JVM(一)</title>
      <link href="/2017/02/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E4%B8%80/"/>
      <url>/2017/02/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>Java虚拟机提供了Java class文件的运行时环境，java的平台无关性、语言无关都是依赖于不同平台的JVM实现屏蔽了操作系统的底层差异、以及制定的class文件标准。</p><span id="more"></span><p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不需要为每一个new操作去写配对的delete&#x2F;free代码，不容易出现内存泄露和内存溢出问题。不过也正是因为Java虚拟机拥有内存控制的权利，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机的内存管理机制，那么排插问题将会非常困难。这次整理下JVM的自动内存管理机制的相关内容。</p><h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><p><img src="http://ww1.sinaimg.cn/large/a1d44fefgy1fce5xu1r4oj20d70b2q4b"></p><p>Java内存模型是指Java程序运行时的内存模型。可分为线程私有和共享数据区两大类。</p><p>线程私有：</p><ul><li>程序计数器（Program Counter Register）  记录正在执行的字节码指令地址</li><li>Java虚拟机栈 （Java Virtual Machine Stacks） Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）</li><li>本地方法栈 （Native Method Stack） Native方法执行的内存模型</li></ul><p>线程共享：</p><ul><li>Java堆 （Java Heap） 存放对象实例，垃圾收集器管理的主要区域</li><li>方法区 （Method Area） 存储已被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据。<ul><li>运行时常量池（Runtime Constant Pool） 编译期生成的各种字面量和符号引用</li></ul></li></ul><h2 id="程序计数器-（Program-Counter-Register）"><a href="#程序计数器-（Program-Counter-Register）" class="headerlink" title="程序计数器 （Program Counter Register）"></a>程序计数器 （Program Counter Register）</h2><p>可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于Java虚拟机是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器核心只会执行一条线程的指令，因此为了保证线程得到CPU执行时间时能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，互不影响，独立存储。这类内存区域称为“线程私有的”内存。</p><p>如果正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。<br><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p><h2 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h2><p>虚拟机栈描述的是Java方法的运行时内存模型：每个方法运行时都会创建一个栈帧（Stack Frame）用于存储方法的局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程都对应着一个栈帧在虚拟机栈中出栈入栈的过程。</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、long、double）、对象引用（reference类型）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型占用1个。局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p><ul><li>如果线程请求的栈深度大于虚拟机允许的深度，将抛出 <code>StackOverflowError</code> 异常；</li><li>如果虚拟机在栈扩展时无法申请到足够的内存，将抛出 <code>OutOfMemoryError</code> 异常。</li></ul><h2 id="本地方法栈-（Native-Method-Stack）"><a href="#本地方法栈-（Native-Method-Stack）" class="headerlink" title="本地方法栈 （Native Method Stack）"></a>本地方法栈 （Native Method Stack）</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，他们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><p>Java虚拟机规范对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。Sun HotSpot虚拟机中，直接把本地方法栈和虚拟机栈合二为一。</p><p>与虚拟机栈一样，本地方法栈也会抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>异常。</p><h2 id="Java堆（Java-Heap）"><a href="#Java堆（Java-Heap）" class="headerlink" title="Java堆（Java Heap）"></a>Java堆（Java Heap）</h2><p>在虚拟机启动时创建。此内存的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。虚拟机规范中描述的是：所有的对象实例以及数组都要在堆上分配。但是随着JIT编译期的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术使得所有的对象都分配在堆上也渐渐变得不是那么绝对了。</p><p>当前主流的虚拟机都将Java堆实现为可扩展的（通过-Xmx和-Xms控制），如果在堆中没有完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap，目的应该是与Java堆区分开来。</p><p>在jdk1.7及之前，在官方的HotSpot虚拟机中方法区被称为永久代（Permanent Generation），因为HotSpot虚拟机把GC分代收集扩展至方法区。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。永久代的内存受 <code>-XX:MaxPermSize</code>的限制。</p><p>在jdk1.8中，永久代被完全移除，取而代之的是元空间（Metaspace），并且使用的是本地内存，理论上只要不触及进程的内存上限，例如32位操作系统的4GB，就不会出现问题。Metaspace的大小由 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 设置。</p><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期间才能产生，也就是并非预置如Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也能将新的常量放入池中，这种特性被开发人员利用的比较多的就是String类的intern()方法。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><h2 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h2><p>在JDK1.4中心加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><p>显然，本机直接内存的分配不会受到Java堆大小的限制，但作为内存区域一样受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及物理存储空间的限制。当JVM使用的直接内容加上JVM其他内存大于物理内存限制时，会导致动态扩展时出现OutOfMemoryError异常。</p><h1 id="垃圾收集与内存分配"><a href="#垃圾收集与内存分配" class="headerlink" title="垃圾收集与内存分配"></a>垃圾收集与内存分配</h1><p>1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾手机技术的语言（Lisp真是一门伟大的语言）。GC技术的三个要点：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><h2 id="哪些对象需要回收"><a href="#哪些对象需要回收" class="headerlink" title="哪些对象需要回收"></a>哪些对象需要回收</h2><p>垃圾收集器在对java堆进行回收前，第一件事就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法（Reference Counting）：给对象添加一个引用计数器，每当一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>客观的说，引用计数法的实现简单，判定效率也很高，Python就是使用了引用计数算法进行内存管理。但是主流的Java虚拟机中没有选用引用计数法来管理内存的，其中最主要的原因就是它很难解决对象之间相互循环引用的问题。例如对象A引用对象B，对象B又同时引用了对象A（objA.instance&#x3D;objB；objB.instance&#x3D;objA;）。除此之外，这两个对象在其他地方并没有被引用，实际上这两个对象已经不可能被访问，但是他们因为互相引用着对方，导致它们的引用计数都不为-，于是引用计数算法无法通知GC收集器回收它们。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>主流的商用程序语言（Java、C#、包括古老的Lisp）的主流实现中，都是通过可达性分析来判定对象是否存活的。</p><p>可达性分析（Reachability Analysis）：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（一般说的Native算法）引用的对象</li></ul><h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>HotSpot中的方法区（永久代）的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p><p>回收废弃常量与回收Java堆中的对象非常相似。例如字符串”abc”已经进入了常量池，如果当前系统中没有任何一个String对象引用了常量池中的”abc”(String a &#x3D; new String(“abc”);)，也没有其他地方引用了这个字面量（String a &#x3D; “abc”;），如果这时发生了内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻的多。类需同时满足下面3个条件才能算是“无用的类”：</p><ol><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li><li>加载该类的ClassLoader已经被回收；</li><li>该类对用的java.lang.Class 对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。</li></ol><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除算法（Mark-Sweep）：如同它的名字一样，算法分为“标记”和“清除”两个阶段。</p><p>首先标记处所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>标记-清除算法的主要不足有两点，一是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续的内存而不得不提前触发另一次GC。</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决效率问题，一种称为“复制”（Copying）的手机算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上去，然后再把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等的复杂情况，只要移动堆指针，按顺序分配内存即可。</p><p>现在的商业虚拟机都是采用这种收集算法来回收新生代。将新生代分为较大的Eden区，用于对象的创建，和两块较小的Survivor区，每次只使用Eden区和其中一个Survivor区，HotSpot虚拟机默认Eden与Survivor的比例为8:1，这样内存利用率可以达到90%，由于对象存活率较低，所以，在新生代GC的时候，一个Survivor通常可以满足存活对象的需求。如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保进入老年代。</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>复制收集算法适用于对象存活率低的情况，这样在内存利用率可以接受的情况下，保证了GC的效率。然而对于对象存活率较高的情况，复制算法就不适用了。</p><p>标记-整理（Mark-Compact）算法：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection ）算法，就是根据对象存活周期的不同将内存分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据不同区域的对象存活特点采用最适当的收集算法。</p><p>在新生代中，每次垃圾收集时都发现又大批对象死去，只有少量存活，因此选用复制算法，只需复制少量存活对象即可。而老年代因为对象存活率高、没有额外空间对它进行分配担保，就使用“标记-整理”或“标记-清理”算法来回收。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><img src="http://ww1.sinaimg.cn/large/a1d44fefgy1fcttvfgg50j20f70aeaab"><br>使用 <code>-XX:+PrintCommandLineFlags</code> 显示当前使用的收集器</p><h1 id="JDK自带工具"><a href="#JDK自带工具" class="headerlink" title="JDK自带工具"></a>JDK自带工具</h1><ul><li>jps [-l] [-v] 显示正在运行的虚拟机进程</li><li>jstat 用于监视虚拟机各种运行状态信息<br><code>jstat -gc 2764 500 20</code> 每500毫秒查询一次进程2764的垃圾收集状况，一共查询20次  <ul><li>-class 监视类装载、卸载、总空间以及类装载所耗费的时间</li><li>-compiler 输出JIT编译期编译过的方法、耗时时间</li><li>-gcutil 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</li><li>-gccause 与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</li></ul></li><li>jinfo 实时的查看虚拟机的各项参数<br><code>jinfo -flag CMSInitiatingOccupancyFraction 1444</code> 查看CMS收集器出发FULL GC的老年代占用百分比</li><li>jmap Java内存映像工具<br><code>jmap [options] vmid</code><ul><li>-dump 生成Java堆转储快照</li><li>-heap 显示Java堆详细信息，如使用哪种回收器、参数配置、分代状况。只在Linux&#x2F;Solaris平台下有效</li><li>-F 当虚拟机进程对 -dump 选项没有响应时，强制生成dump快照。只在 Linux&#x2F;Solaris 平台下有效</li></ul></li><li>jhat 虚拟机堆转储快照分析工具</li><li>jstack java堆栈跟踪工具（生成当前线程快照）<ul><li><code>jstack 2222 &gt; stack.log</code> 生成进程2222的快照，保存到stack.log文件中</li><li>-F 当正常输出的请求不被响应时，强制输出线程堆栈</li><li>-l 除堆栈外，显示关于锁的附加信息</li><li>-m 如果调用到本地方法的话，可以显示C&#x2F;C++ 的堆栈</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 读书 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016 SUMMARY</title>
      <link href="/2016/12/31/2016-SUMMARY/"/>
      <url>/2016/12/31/2016-SUMMARY/</url>
      
        <content type="html"><![CDATA[<h1 id="年终小感想"><a href="#年终小感想" class="headerlink" title="年终小感想"></a>年终小感想</h1><p>在我开始写这篇文章的时候，2016年还剩下不到15分钟了。</p><p>时间过的可真是快，github博客开了快一年了。怎么感觉好像是上星期才开的呢？还记得当时开博客的初衷，梳理一些学习笔记，记录一些个人想法，算是个笔记本吧然而下半年却没有坚持下来，惭愧。回望这一年，有收获也有很多挫折。但是却好像没有什么比较大的进步，试问下自己你这一年比年初的时候有什么变化了呢？有了什么大的进步？好像一下子并不能回答上来。</p><span id="more"></span><p>细思极恐啊，如果每年年终都是这样，那等到我垂暮之年，躺在床上岂不悔恨，郁郁而终。</p><p>既然是总结，那就还按照最常见的套路：回顾下过去，总结下现在，展望下未来。然后最后再想到哪写到哪，随便扯扯吧。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100" height="5" src="//music.163.com/outchain/player?type=2&id=440241144&auto=1&height=66"></iframe><h1 id="我的2016小结"><a href="#我的2016小结" class="headerlink" title="我的2016小结"></a>我的2016小结</h1><h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>大概是在2014年吧，养成了买书的习惯。这个习惯真不全是褒义。书要读了才能发挥它的价值。那一段时间真是狂买书，一个月买了十几本，而且我读书速度极慢，现在一大箱子书还有好多没读的。</p><p>来列一下2016读过的感觉不错的书吧</p><ul><li><p>《重构 改善既有代码的设计》</p><p>读完这本书，不仅仅是如何重构一个程序。对于我来说，动手写的时候如何组织自己的代码都提供了一些有效的思路，毕竟写机器能读懂的代码很容易，写出人能轻松读懂并且乐于读的代码却不那么简单。现在入职没多久的这家公司所接的这个系统真是深有体会。</p></li><li><p>《写给大忙人看的Java SE 8》</p><p>关于Java8一些新特性的介绍。话说这本书还是在凤凰书城看到了，回来就在网上买了（因为可能觉得网上的比较便宜吧哈哈）。看完这本书不仅是对Java8的Stream，lambda 有了一定的了解，在工作中可以比较熟练的应用。对函数式编程也有了些了解吧。以至后来看再Python的函数式编程，也不是那么生涩了。</p></li><li><p>《上帝掷筛子吗？》</p><p>这个是在kindle上看完的，难得忍住没买纸质书，我想如果是技术书可能会买吧。这本书比较通俗的讲了量子物理的发展史，连我这种弱鸡都能看的似懂非懂。牛顿，麦克斯韦，海森堡，波尔，爱因斯坦… 要说世界上有那么一群人不为了金钱权益去努力，却大大的推动了人类社会发展的话，我想说的大概就是这么一群人了。</p></li><li><p>《深入理解Java虚拟机》</p><p>Java界的操作系统书。</p></li></ul><p>嗯，以上，是今年完整读完至今还有印象的几本书。卧槽，我这一年才读了这么几本书（捂脸）。当然还有买了《普林斯顿微积分读本》（因为想着好好补足下数学，向着数据挖掘，ML，DeepLearning 进发），Mysql技术内幕，编程珠玑（很经典的一本书了）等等吧，只好列入明年计划了。</p><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><ul><li><p>《你的名字》 新海诚的作品，据说堪比宫崎骏，其实我看故事风格跟宫崎骏类型还是有比较大的差异，就是时间线略复杂（没完全懂好吗）。话说单身狗去看这部电影完全是挑战自己的受打击底线去了。</p></li><li><p>《长城》 国师张艺谋的商业大作（其实好莱坞风格更明显一些）。褒贬在知乎，豆瓣上有很多了。</p></li><li><p>《罗曼蒂克消亡史》 这个应该是属于文艺片吧？也是自己一个人跑去影院看的，看完心里还郁闷了好一会。略血腥暴力。对于电影中的结局导演想要表达思想却没有太明白。</p></li></ul><p>现在比较有印象的就是这三部电影了，因为是最近才看的（囧）。。。</p><h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><p>老是提旅行二字，我都感觉有点不太好意思。因为好像都没出去过几次。不过心里还是有一颗走出去的心哒。年初走徽杭古道，本来打算写篇文章的，后来也没动手。关于泰国行，又是个装逼吹比的好材料，动手搭了架子，也没写完。。因为对于写文章的能力 真是已经退化到小学生水平了，甚至小学生都不如（因为我小学时候写作能力还是很好哒）。明年要抽口出去走走了。</p><h2 id="收获or进步"><a href="#收获or进步" class="headerlink" title="收获or进步"></a>收获or进步</h2><p>编程能力提高了？工资涨了？（手动捂脸）</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>最近周末都去南大那边上课，老师是南大的博士。真真切切的感受到，长的比你高 比你帅 比你有钱的人 还他么比你努力。。。</p><p>还记得16年初的时候自己定的几个目标。好像一个都没实现（打脸）。</p><p>前两天在知乎上看到一个答主说（大意是这样），人的求知历程 可分为四个阶段：不知道自己不知道，知道自己不知道，不知道自己知道，知道自己知道。。 这个我还是很认同的。感觉自己要在知道自己不知道这个阶段走好久。。我好方。这都是自己以前不努力学挖下的坑。</p><p>2017，希望爸爸 妈妈身体健康，平平安安 快快乐乐的，等我有能力买栋大房子住（好像很遥远哎）。妹妹学业有成，做自己喜欢做的事。身边的同学朋友都越来越好 一个都不能少。</p><p>对于自己，不想立什么flag了：</p><ul><li><p>多读几本书，静下心来读</p></li><li><p>17年的两次考试要都过</p></li><li><p>2017 能不能找到女朋友？？？</p></li></ul><p>没想到这么一小篇文章竟然从去年写到了今年，写了一个小时，然后现在头脑昏昏沉沉的。。。今年这个跨年貌似蛮有意义的。</p><p>祝所有人新年快乐！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清迈-阵雨中行走的城市</title>
      <link href="/2016/08/02/%E6%B8%85%E8%BF%88-%E9%98%B5%E9%9B%A8%E4%B8%AD%E8%A1%8C%E8%B5%B0%E7%9A%84%E5%9F%8E%E5%B8%82/"/>
      <url>/2016/08/02/%E6%B8%85%E8%BF%88-%E9%98%B5%E9%9B%A8%E4%B8%AD%E8%A1%8C%E8%B5%B0%E7%9A%84%E5%9F%8E%E5%B8%82/</url>
      
        <content type="html"><![CDATA[<h1 id="清迈（Chiangmai）游记"><a href="#清迈（Chiangmai）游记" class="headerlink" title="清迈（Chiangmai）游记"></a>清迈（Chiangmai）游记</h1><blockquote><p>清迈市（泰语：เชียงใหม่），是泰国第二大的城市，是清迈府的首府，也是泰国北部政治、经济、文化的中心。人口约25万人。清迈是泰国北部最大的历史文化城市，也是泰北政治经济中心。为清迈府首府，在1296年至1768年间为兰纳王国首都。 -摘自 维基百科</p></blockquote><p>公司组织泰国游，前两拨都去了普吉岛，芭提雅，曼谷，为了不走前人的老路，同时怀着对佛教圣地的敬仰，我们选择了清迈。去之前就听朋友说，去了清迈，至少要待上三四天，才能有机会感受真正的清迈文化。当时不以为然，现在一想，确实如此啊。</p><span id="more"></span><h1 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h1><h1 id="雨"><a href="#雨" class="headerlink" title="雨"></a>雨</h1><h1 id="景"><a href="#景" class="headerlink" title="景"></a>景</h1><h1 id="人"><a href="#人" class="headerlink" title="人"></a>人</h1>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lucene源码剖析中文版</title>
      <link href="/2016/06/26/Lucene%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%AD%E6%96%87%E7%89%88/"/>
      <url>/2016/06/26/Lucene%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E4%B8%AD%E6%96%87%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h4 id="Lucene源码剖析中文版"><a href="#Lucene源码剖析中文版" class="headerlink" title="Lucene源码剖析中文版"></a>Lucene源码剖析中文版</h4><p><strong>好东西，要分享</strong></p><p><a href='/books/Annotated-Lucene源码剖析中文版.pdf'>Lucene源码剖析中文版</a></p>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 技术 </tag>
            
            <tag> Lucene </tag>
            
            <tag> 搜索引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>醉翁亭游记</title>
      <link href="/2016/06/11/%E9%86%89%E7%BF%81%E4%BA%AD%E6%B8%B8%E8%AE%B0/"/>
      <url>/2016/06/11/%E9%86%89%E7%BF%81%E4%BA%AD%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<pre><code class="我是一个待填的坑~~~~~"></code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我也不知道为什么，突然想写点什么</title>
      <link href="/2016/05/30/%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E7%AA%81%E7%84%B6%E6%83%B3%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88/"/>
      <url>/2016/05/30/%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E7%AA%81%E7%84%B6%E6%83%B3%E5%86%99%E7%82%B9%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h3 id="我也不知道为什么，突然想写点什么"><a href="#我也不知道为什么，突然想写点什么" class="headerlink" title="我也不知道为什么，突然想写点什么"></a>我也不知道为什么，突然想写点什么</h3><p>零点，听着王菲的歌，书也没看下去，毫无睡意，想起来博客好久没更了。我也不知道为什么，突然想写点什么，随便写，反正也没人看。</p><span id="more"></span><h3 id="一个没有手机的夜晚"><a href="#一个没有手机的夜晚" class="headerlink" title="一个没有手机的夜晚"></a>一个没有手机的夜晚</h3><p>这是一个没有手机的夜晚，上星期下雨天手滑，手机没拿住掉在地上屏幕摔碎了。坚持了一星期，还是决定拿去修吧，毕竟6s，屏幕碎了，怎么看怎么像山寨机。而且平时看着手机觉得眼晕。but，一个屏940，真是贵。<br>顺带体验一下没有手机的一天是什么感觉。这个社会，人们总是被手机，电脑，APAD，各种互联网设备包围，真的有太少时间去静下来，思考。身处互联网这个行业，深有体会。最近略忙，书都很少看了，不，应该说是看不下去了。</p><h3 id="你为什么不快乐"><a href="#你为什么不快乐" class="headerlink" title="你为什么不快乐"></a>你为什么不快乐</h3><p>今年至此，半年过去了，烦躁的情绪始终不散，各种不开心，偶尔也感觉压力好大。总之就是，不开心，不快乐。但是，细想之，我为什么会不快乐呢？我不是也有吃有喝，不用担心明天起来没有去处，为生计而担忧。我为什么会不快乐呢？   </p><p>今晚找房子，逐渐了明白了这一点。和大鹏、小胖一起找房子，三室一厅的房子 找了好几次，始终没有找到合适的，原因大多是关于大小房间价钱的问题意见不统一。晚上终于找到一个性价比超高的房子，而大鹏和小胖关于晒衣服和床的问题有起了争执。</p><p>忽然觉得，之所以不快乐，也许是因为计较的太多。想想之前，虽然对许多事表面装作不关心的样子，但心里却是很在意的，又没有能力去改变，当然就不开心咯。当然，也并不是说所有的事情都不关心，对于自己的目标当然要去尽力实现，但尽力了之后没有达到期望的结果要总结教训，没必要太惋惜。这也许就是佛家讲的’放下’吧。为什么很多人迷然琐事之中，还总是抱怨为什么别人…而我却…种种。大概就是计较了太多，却没有静下心来把该做的事情做好。要达到这种境界还有很长的路要走啊，突然想找个大师开导下呢。</p><h3 id="不将就"><a href="#不将就" class="headerlink" title="不将就"></a>不将就</h3><p>什么鬼，突然循环到《不将就》。一直没有对象，大概就是自己觉得感情，不能将就吧(其实不好意思说是因为矮穷挫)。我也不知道这么坚持对不对，有时候想，不去努力尝试下怎么知道呢，犹豫着犹豫着，就这么错过了一个又一个。大概每个人的心里都会有那么一块地方，一触碰就低头不敢向前，觉得自己是个loser吧。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>听说苹果手机换屏后整机测试不通过会换新机，嘿嘿，苹果，给我换了可好？<br>早起早睡，锻炼身体，好好学习，天天向上。晚安😃</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=“100” height="5" src="http://music.163.com/outchain/player?type=2&id=31134197&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暗黑者外传-惩罚</title>
      <link href="/2016/05/09/%E6%9A%97%E9%BB%91%E8%80%85%E5%A4%96%E4%BC%A0-%E6%83%A9%E7%BD%9A/"/>
      <url>/2016/05/09/%E6%9A%97%E9%BB%91%E8%80%85%E5%A4%96%E4%BC%A0-%E6%83%A9%E7%BD%9A/</url>
      
        <content type="html"><![CDATA[<p>中午吃过饭拿起了kindle，看到前两天加入心愿单的一本《暗黑者外传-惩罚》，名字有点非主流杀马特的感觉，但是看介绍说作者被认为是可以媲美东野圭吾的中国推理作家，并且本书是高智商犯罪扛鼎之作。不由得翻起了样章来读，读完样章意犹未尽，就索性买了整本书，就这么看了一下午。。。我真的是在完成工作任务的基础上看的啊。</p><p>好久没有这么一气呵成的读完一本书了。以一个肾脏科医生的死亡为始通过一系列开始带来希望，然后终又被排除的线索，讲述了一个女医生复仇的故事(可以说是复仇吧)。不仅仅是故事本身，还影射了当今社会的一些问题，比如看病难，比如医保体系，比如贪腐，一些行业潜规则。等等，发人深思。但是作为故事主线人物，庄小溪对自己丈夫又爱又恨的那种感情，大概是最让人纠结的了吧。</p><span id="more"></span><p>作者有没有达到东野圭吾的高度，我不知道。但是跟之前看过的东野圭吾的《嫌疑人X的献身》、《白夜行》来看，真的有些相似之处。大都是因为主角之间的爱恨纠葛而牵扯出来的一系列事件。大概是我见识太少，也许是相对于日本文学对国产作品更接受一些，就像是相对于日本料理，更喜欢中国菜一样，从《惩罚》中，我还看到了当今中国社会许多现实，从地方高官，事业单位(公立医院应该算是事业单位吧？)，到底层人民，能让人深思。</p><p>对我来说，欧美小说像肥肉，太油腻，日本小说像纯瘦肉，太干燥。中国小说才更像是五花肉，吃起来更爽口。哈哈，大概是我修养还不够。</p><p>总的来说，是本好书，今天下午过的很充实，因为沉浸在了一个有血有肉的故事中，无法自拔。。也许现在才刚刚走出来。<br><a href="https://www.amazon.cn/gp/product/B0196NKNHQ/ref=oh_aui_d_detailpage_o00_?ie=UTF8&psc=1">暗黑者外传：惩罚（原名《死亡通知单外传：惩罚》）</a></p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 读书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016年5月1日-劳动.节?</title>
      <link href="/2016/05/02/2016%E5%B9%B45%E6%9C%881%E6%97%A5-%E5%8A%B3%E5%8A%A8-%E8%8A%82/"/>
      <url>/2016/05/02/2016%E5%B9%B45%E6%9C%881%E6%97%A5-%E5%8A%B3%E5%8A%A8-%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<p>今天是劳动节，突然觉得这个名字跟节日好不符。既然是劳动节，就应该是大家一起劳动的日子(脑海中浮现出小学时全校一起大扫除的场景)。非劳动节，大家放假出去玩才对(所以我们一年就应该工作这三天)。Google了一下：</p><blockquote><p>劳动节通常是年度性与全球性的节日，目的是为了庆祝劳动阶级对社会和经济所做的贡献。世界上大多数国家的劳动节是在5月1日（如法国、瑞典），因此通常也称之为国际劳动节。美国和加拿大的劳动节是在9月的第一个星期一。新西兰的劳动节是十月的第4个星期一。澳大利亚不同的地区对劳动节有不同的规定。而日本类似的节日称为勤劳感谢之日在11月23日。</p></blockquote><p>是为了庆祝劳动阶级所做的贡献，而创立的节日。感觉日本的节日名字比较符合些。论起名字的重要性。</p><p>说道Google，不得不提到天朝的百度，我大天朝神一样的百度。快播因为被用户利用传播色情视频被干掉了，百度不仅可以传播色情信息(别问我怎么知道的)，还可以通过更可恶的竞价排名让各种无证小医院在搜索结果上名列前几。所出现的后果，就如最近的一个事件：一个西安电子科技大学的学生得了滑膜肉瘤，通过百度搜索，就医后去世。 类比快播，这难道不是传播虚假医疗信息，是这起医疗事故的帮凶么。这是直接害人命的呀！ 论背后有人的重要性。</p><p>早就这起事件的原因有很多，觉得最重要的两点还是。一，没有竞争者，一个市场的一个领域内没有竞争对手一家独大的情况下，如果是一个脑残无良的公司，很容易出现店大欺客的情况。二，监管，没有竞争者，总有市场监管组织吧。监管组织没有相应完善的规范以及严厉的处罚措施，无良的公司更是无所顾忌了。</p><p>突然想到小学课文里的 猎人打狼保护鹿群的故事。猎人费劲心机把狼群赶出了森林，却不想鹿群却越来越衰弱了。呵呵。</p><p>反正，我是一直用Google了。百度，拜拜</p><p>今天跟胡屁屁，一起住的小胖去了趟珍珠泉，去了有点小失望。商业化的氛围太严重了，各种收费项目不说，一个风景区，景色看不到多少，全是娱乐设施，娱乐设施吧。还全是小型设备。看着那个小型过山车，碰碰车，老子一点玩的欲望都没有(其实是身上钱不够)。说是游乐场吧，有点不伦不类的感觉，分分钟都被常州恐龙园完爆。说真的，适合带着小孩子一起玩。单身狗表示又被虐了次，不对，是N多次。</p><p>回到住处，又困又累啊，毕竟朋友圈运动步数前几了好吗。但是睡前看了下NBA的赛程，挖槽，热火对黄蜂的比赛竟然是凌晨一点？你大爷。还准备美美睡一觉明早起来看的呢。就冲上一场韦德最后时刻的发挥，这场也一定要看。不多说，愿韦德带领热火杀进东决，干掉骑士 送詹姆斯回家。最后 拿下本赛季总冠军，哈哈哈</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>龙卷风</title>
      <link href="/2016/04/17/%E9%BE%99%E5%8D%B7%E9%A3%8E/"/>
      <url>/2016/04/17/%E9%BE%99%E5%8D%B7%E9%A3%8E/</url>
      
        <content type="html"><![CDATA[<p>窗外飘着雨，就像我心血在滴…</p><span id="more"></span><p>匆忙的两天考试结束了。报了三门，考前一周才开始看，本着一定要考过的心态，这周就看了一门，昨天早上放弃了一门没看的。稀里糊涂的考完了，心里还是没底。<br>考试的过程大致是这样的：<br><img src="http://ww4.sinaimg.cn/large/a1d44fefgw1f302oyfsmaj20c20gc0to.jpg"></p><p>又本着不放弃不抛弃的态度，昨天晚上又狂看了今天考的《企业管理咨询》，看到近一点，早晨又早起看了一会。今天考的感觉还好吧。能写的都写上了。对于这个不放弃的自己，要赞一下。哈哈。</p><p>考完试，今天下午忽然觉得有点空，又打了几局游戏。之所以感觉空，大概是一段时间努力要做的事，做完了。一下子人回到放空的状态了吧。。真是可恶，明明还有好多东西要学，好多书要看呢。</p><p>最近身体也总是出问题，要么是牙疼，要么是胃疼 (还偶尔伴随着蛋疼)。。去的医院次数真是比前二十年的总和还要多了。。每周的运动量要加大了。</p><p>下午外面又下起了雨，VPN到公司内网，撸着代码。听着歌，听到周董的《龙卷风》。</p><p>周董把爱情比作龙卷风真是贴切，因为有些人，像我，可能一辈子都不会遇见龙卷风。</p><p>网易，还是没办法贴周董原唱。。。贴个甜甜的女声</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100" height="86" src="http://music.163.com/outchain/player?type=2&id=289415&auto=1&height=66"></iframe>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天科比退役了</title>
      <link href="/2016/04/15/%E4%BB%8A%E5%A4%A9%E7%A7%91%E6%AF%94%E9%80%80%E5%BD%B9%E4%BA%86/"/>
      <url>/2016/04/15/%E4%BB%8A%E5%A4%A9%E7%A7%91%E6%AF%94%E9%80%80%E5%BD%B9%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>今天科比退役了</p><span id="more"></span><p>以后或许再也听不到有人说，今天科比好牛叉啊，又得了多少多少分，哎呀 那个进球太屌了。卧槽 今天科比又打了多少铁 哈哈。。。</p><p>今天科比退役了</p><p>NBA与我有关的记忆又少了一段</p><p>还记得那年上高二，听百岁说着如日中天的湖人。。恩，那时候我还是个篮球白痴，但那时，科比的名字已经不再陌生了。。虽然08年奥运会我看到了韦德。<br>还记得上大学，那时湖人已经沦落为二三流球队，进季后赛都略显艰难。还是经常听到同宿舍忠实艾迷头哥念叨着艾弗森与科比的恩怨。<br>他们，一个是科密一个是科黑。</p><p>不管是科密，还是科黑，我想今天，心里总是有些触动吧。。岁月真是把双刃剑，他把你变得成熟，变得强壮，更有资本去奋斗，而当你意犹未尽时，却已过了那个疯狂的年纪。科比说，真难想象20年过的这么快，真的是太疯狂了。。</p><p>今天黑曼巴拼尽全力，给自己来了一场完美谢幕。告诉所有人，他还没老。</p><p>卧槽，写到这，竟然想哭，今天看到他最后翻盘的时刻真的落泪了。</p><p>枉我说喜欢韦德说了N多年，现在科比退役竟然这么有感触。韦德告诉我什么叫无兄弟不篮球，科比告诉我 总有人要成功，那个人为什么不能是我？<br>以后NBA的赛场上再也看不到他的身影，可是那个凌晨四点在球场训练的科比会一直在我心中。。激励着我也一直努力，努力去拿属于自己的冠军奖杯。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100" height="5" src="http://music.163.com/outchain/player?type=2&id=16435049&auto=1&height=66"></iframe>曼巴，慢走！![](/heroes.jpg)]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 篮球 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哎呦，晴天哦</title>
      <link href="/2016/04/10/%E5%93%8E%E5%91%A6%EF%BC%8C%E6%99%B4%E5%A4%A9%E5%93%A6/"/>
      <url>/2016/04/10/%E5%93%8E%E5%91%A6%EF%BC%8C%E6%99%B4%E5%A4%A9%E5%93%A6/</url>
      
        <content type="html"><![CDATA[<p>超喜欢这天气。<br>这个时节，晚春(初夏?)的晴天，早晨不会冷，中午不会太热，晚上暖暖的，走在路上，放眼望去，道路两旁都是绿油油的树木，真是让人心情不要太好。</p><p>本来想贴周董的原唱，可是…网易啊，你什么时候能把版权搞好？不过，刘瑞琦唱的也是不错，原版听着听着就听出了回忆，刚好，换种感觉吧。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100" height="5" src="http://music.163.com/outchain/player?type=2&id=30394763&auto=1&height=66"></iframe><span id="more"></span><p>尤其一天那种不是很热，暖暖的太阳，照在身上，就像是披上了一层丝绵被子。</p><p>今天真是出奇的想一个人静一静，要是平常这种天气，肯定是约上几个人一起，或者去打球，或者去爬山，获取去瞎转。今天有人叫我去打球，我竟然毫无去意。就是感觉这么好的一天，要一个人好好享受下。也许是最近心里有些乱吧，想要一个人静一静，一个人看看书，随便逛逛，听听音乐。身处在热闹的环境中久了，就希望有独处的空间。一个人独处久了也一样，总想要有人一起聊聊天，热闹一下。之前不知在哪里听到一句话，优秀的人，总是孤独的。乍听之下，只是这句话貌似逼格较高。但仔细思考下，也不无道理啊。啥叫优秀？优秀不就是比身边人或者专业技能强，或者思考的更远，更细，更有想法，或者是更有内涵，更有气质，总之，是有一方面或者多方面都比较突出的人吧。那这个人就肯定有孤独的以免或者说孤独的时候吧，因为总有一些事是无法向身边人分享的。总有一些事，是只有自己能领悟，可以明白，可以去做。正所谓高处不胜寒，大概就是这个道理吧。说了这么多，并不是说我是个多么优秀的人，恰恰相反，我觉得自己还差的太很多(汗颜)。。只是，一个人每天接触那么多人、事物，总要留出那么一部分时间去思考下。毕竟，人，是一根能si思想的苇草嘛。。</p><p>本来今天打算是要看书的，报的自学考试，下周就要开考了。报了三门，可以一门也没看。。因为一想到 不是自己感兴趣而是为了拿学位，为了考试。。总觉得是在浪费时间。竟没有心思看下去。抱着试试看，估计会是被骗的态度，花钱买了份答案。。果不其然，发来的竟是一份加密的zip文件，想要解密还要再加钱。。好吧，就当是对想投机取巧的自己的一点惩罚，有时候，想要投机取巧是行不通的。还是踏实点好。</p><p>但是，这zip文件哥就放着不问了吗，哥能忍？我拒绝！想到正好前阵子买的书《运用Python成为顶级黑客》中有提到Python破解zip文件，真实欣喜往外啊，一想到哥拿着破解的答案，把截图发给那鸟人(卖答案的骗子)，告诉他，看到没，妈的 发了一堆种子，还尼玛是葫芦娃的，以为哥看不了不知道？卧槽，想想就激动，又看到书中提到的Kali linux，兴致一来，想着把这个系统(一些基本配置，vim的配置)也配一下。可我这电脑一个屏幕实在蛋疼，突然又想到公司还有一个快递忘了拿回来。就想着干脆去公司算了。DELL显示屏扩展玩着多爽啊。</p><p>于是，就开着我那全景天窗，无极变速的超级豪华山地车去了公司。刚到公司，就接到了旁边死胖子的电话(这货一般情况下根本联系不到)，他也要来公司，好巧。。</p><p>废话少说，到了公司，翻到讲破解zip文件的那部分，当时就泄了气，只是讲了暴力破解，就是狂猜密码。然后去解压。这岂不是要猜死。网上找了几个密码字典，都没成功，更深入的关于加密算法，加密方式的方法，就不太明白了。。看来以后还是老老实实的看书记笔记吧。</p><p>重点来了，大概下午6点半的样子吧，大道回府，一出门，还有夕阳的余晖，两边绿油油的树木，暖洋洋的空气，顿时心情又大好啊。还拍了照片的，这么晚了，懒得传了。</p><p>本来打算吃个饭回来更的，但是舍友非拉着我打局LOL，没想到一局打了将近一小时。虽然晚上听到一些流言，虽说和我关系不是很大吧，还是不要影响心情了。生活本无事，庸人自扰之，越来越觉得和简单、优秀的人相处的必要性。</p><p>经常写一些东西，果然还是有效果的，感觉自己越来越理性中透着文艺了呢。<br>都已经一点半了。。</p><p>就酱，晚安😊。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性概览(四)</title>
      <link href="/2016/04/05/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88(%E5%9B%9B)/"/>
      <url>/2016/04/05/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<h3 id="杂项改进"><a href="#杂项改进" class="headerlink" title="杂项改进"></a>杂项改进</h3><p>除了lambda和stream Api等重大改进外，Java8 还对库进行了大量微小却实用的改进。包括对 字符串、数字、数学、集合、文件、注解、正则表达式及JDBC等。</p><span id="more"></span><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li><p><code>String.join()</code><br>我们经常会遇到这样的需求：将多个字符串通过一个分隔符链接起来。现在Java8中 String 类中新增的 <code>join</code> 方法可以实现这个功能。这是Java8中String类添加的唯一一个方法。字符串可以来自于一个数组或者一个<code>Iterable&lt;? extends CharSequence&gt;</code> (可迭代的)对象  </p><pre><code>    String joined = String.join(&quot;/&quot;, &quot;usr&quot;, &quot;local&quot;, &quot;bin&quot;); // &quot;usr/local/bin&quot;    System.out.println(joined);    String ids = String.join(&quot;, &quot;, ZonedId.getAvailableZoneIds()); // 将可用时区id连接成为字符串    System.out.println(ids);// 在我的电脑上：Asia/Aden, America/Cuiaba, Etc/GMT+9, Etc/GMT+8, Africa/Nairobi, America/Marigot...</code></pre></li></ul><h4 id="数字类"><a href="#数字类" class="headerlink" title="数字类"></a>数字类</h4><ul><li>BYTES 字段 与 SIZE 字段<br>从Java5开始，7中原始类型的包装类(不包含Boolean)都提供了一个<code>静态字段SIZE</code>，用来表示该类型以<code>bit</code>为单位的长度。在Java 8 中，他们都提供了一个<code>BYTES</code>字段，以byte为单位来表示该类型的长度，以便于无法被8整除的情况。</li><li>hashCode 方法<br>所有原始类型的包装类都提供了一个静态的hashCode方法，用来返回与实例方法想用的哈希码，这样就不需要在经历 装箱&#x2F;拆箱 的过程了。</li><li>静态 sum、max、min<br>Short、Integer、Long、Float、Double这5种类型，现在分别提供了静态方法 sum、max、min，用来在流操作中作为聚合(reduce)函数使用。同样，Boolean类现在也提供了静态方法 logicalAnd、logicalOr、logicalXor</li><li>无符号计算<br>Integer类现在支持无符号计算。例如，以往Byte表示从 -128到127的范围，现在可以调用静态方法 Byte.toUnSignedInt(b);来获取一个从-到255的值。一般来说，使用无符号数字，你会丢失负数并获得原来两倍范围的整数。<br>Integer和Long类中新增了处理无符号值的 <code>compareUnsigned</code>、<code>divideUnsigned</code> 和 <code>remainderUnsigned</code> 方法。你不需要特殊的方法来计算加法、减法 和 乘法。操作符 <code>+</code> 和 <code>-</code>已经能够正确的处理无符号值。由于大于 <code>Integer.MAX_VALUE</code>的无符号整数相乘会溢出，对于溢出的数值，应当调用<code>toUnSignedLong</code>将值作为长整形。</li><li>BigInteger.(long|int|short|byte)ValueExact()<br>BigInteger类新增加了实例方法 (long|int|short|byte)ValueExact，分别用来返回 long、int、short 或者 byte。并且当值不在目标范围内时抛出一个 ArithmeticException异常。</li></ul><h4 id="新的数学函数"><a href="#新的数学函数" class="headerlink" title="新的数学函数"></a>新的数学函数</h4><ul><li>(add|subtract|multiply|increment|decrement|negate)Exact 参数为int和long类型的值<br>如果结算结果溢出会抛出一个异常。 <code>toIntExact</code>方法可以将一个long值转换为等价的int值</li><li>floorMod(取余)、floorDiv(整除)</li><li>Math.nextDown() Math.nextUp()<br>  Math.nextDown() 返回一比指定数字小，但最接近指定数字的浮点数字</li></ul><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p> 集合库的最大改变就是支持了Stream。同时，还有其他的一些略小改动。</p><table><thead><tr><th align="left">类&#x2F;接口</th><th align="left">新方法</th></tr></thead><tbody><tr><td align="left">Iterable</td><td align="left">forEach</td></tr><tr><td align="left">Collection</td><td align="left">removeIf</td></tr><tr><td align="left">List</td><td align="left">replaceAll</td></tr><tr><td align="left">Map</td><td align="left">forEach, replace, replaceAll, remove(key, value)(只有当key到value的映射存在时才删除), putIfAbsent, compute, computeIf(Absent or Present), merge</td></tr><tr><td align="left">Iterator</td><td align="left">forEachRemaining</td></tr><tr><td align="left">BitSet</td><td align="left">stream</td></tr></tbody></table><ul><li>removeIf 立即删除匹配的值</li><li>forEachRemaining 将剩余的迭代元素都传递给一个函数</li><li>BitSet 类有一个方法可以生成集合中的所有元素</li></ul><h4 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h4><h4 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h4><p>Comparator接口新增的静态方法<code>comparing</code>可以接受一个“键提取器”，将某类型映射为一个可比较的类型(例如String)。<br>例如：<code>Arrays.sort(people, Comparator.comparing(Person::getName));</code><br>通过<code>thenComparing</code>方法进行多级比较<br>例如： <code>Arrays.sort(people, Comparator.comparing(Person::getLastName)).thenComparing(Person::getFirstName);</code>,如果两人拥有相同的姓，就会使用第二个比较器。<br>Comparator新增的<code>comparingInt</code>、<code>comparingLong</code>、<code>comparingDouble</code>方法可以避免int、long、double值得装箱拆箱。<br><code>Arrays.sort(people, Comparator.comparingInt(p -&gt; p.getName().length()));</code><br>当键提取器可以返回null时，可以使用<code>nullsFirst</code>或者<code>nullsLast</code>方法，该方法接受一个比较器来比较两个字符串。<br>例如： <code>Arrays.sort(people, Comparator.comparing(Comparator.nullsFirst(Comparator.naturalOrder())))</code>，<br>naturalOrder方法可以为实现了Comparable接口的类生产一个比较器。 <code>reverseOrder</code>与<code>naturalOrder().reverse()</code>可以实现倒序。</p><h4 id="使用文件"><a href="#使用文件" class="headerlink" title="使用文件"></a>使用文件</h4><p>java8为使用流读取文件行及访问目录提供了一些简便的方法。</p><p>使用<code>Files.lines()</code>方法。它会产生一个包含字符串的流，每个字符串就是文件的一行。</p><pre><code>  Stream&lt;String&gt; lines = Files.lines(path); // lines方法默认会以 UTF-8字符编码打开文件  Optional&lt;String&gt; passwordEntry = lines.filter(s -&gt; s.contains(&quot;password&quot;)).findFirst();</code></pre><p>Stream 接口继承了 AutoClosable 类。可以使用Java7提供的try-with-resources 来关闭底层打开的文件：</p><pre><code>  try (Stream&lt;String&gt; lines = Files.lines(path)) &#123;    Optional&lt;String&gt; passwordEntry = lines.filter(s -&gt; s.contains(&quot;password&quot;)).findFirst();  &#125; // 这里首先会关闭流，然后紧接着关闭文件</code></pre><p>如果希望关闭流的时候收到通知，可以附加一个onClose方法：<br>      try (Stream<String> lines &#x3D; Files.lines(path).onClose(() -&gt; System.out.println(“closing…”))) {<br>        Optional<String> passwordEntry &#x3D; lines.filter(s -&gt; s.contains(“password”)).findFirst();<br>      } &#x2F;&#x2F; 这里首先会关闭流，然后紧接着关闭文件</p><h4 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h4><p>Base64编码可以将一组字节序列编码为一个(更长的)可打印的ASCII字节序列。它经常用于电子邮件消息中的二进制数据，以及“基本的”HTTP认证。</p><p>现在Java8提供了一个标准的编码器和解码器。</p><pre><code>  //编码：  Base64.Encoder encoder = Base64.getEncoder();// getEncoder, getUrlEncoder, getMimeEncoder  String original = username + &quot;:&quot; + password;  String encoded = encoder.encodeToString(original.getBytes(StandardCharsets.UTF_8));  // 还可以“包装”一个输出流，这样所有发送给它的数据都会自动进行编码。  Path originalPath = ..., encodedPath = ...;  Base64.Encoder encoder = Base64.getMimeEncoder();  try (OutputStream output = Files.getOutputStream(encodedPath)) &#123;    Files.copy(originalPath, encoder.wrap(output)); // 源地址copy到编码地址  &#125;  // 解码， 只需要将这些操作反过来  Path encodedPath = ..., originalPath = ...;  Base64.Encoder = Base64.getMimeEncoder();  try (InputStream input = Files.newInputStream(encodedPath)) &#123;    Files.copy(decoder.wrap(input), decodedPath); // 从编码地址 copy到解码地址  &#125;</code></pre><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul><li>可重复的注解 @Repeatable</li><li>可用于类型的注解</li><li>方法参数反射，及可以通过反射获取方法参数的名称</li></ul><h4 id="其他一些细微的改进"><a href="#其他一些细微的改进" class="headerlink" title="其他一些细微的改进"></a>其他一些细微的改进</h4><ul><li>Null检查，Objects类新增了两个静态predicate方法isNull 和 nonNull。可以在流中使用，来过滤元素</li><li>正则表达式， Pattern 新增 splitAsStream方法，可以将一个CharSequence按照正则表达式进行分割</li><li>语言环境</li><li>JDBC。java8中，jdbc升级到了版本4.2。java.sql 包中的Date,Time,Timestamp类都提供了一些方法，可以与java.time报下对应的LocalDate,LocalTime,LocalDateTime互相转换</li><li>Statement类新增了一个executeLargeUpdate方法，用来执行修改函数会超过Integer.MAX_VALUE的更新操作</li><li>JDBC4.1 为Statement和ResultSet执行了一个泛型方法，getObject(column, type)。其中type是一个Class实例<br>  例如：<code>URL url = result.getObject(&quot;link&quot;, URL.class);</code> 当然也提供了相应的setObject方法。</li></ul><h3 id="容易被忽略的Java7特性"><a href="#容易被忽略的Java7特性" class="headerlink" title="容易被忽略的Java7特性"></a>容易被忽略的Java7特性</h3><ul><li>对所有实现AutoCloseable接口的对象使用try-with-resources语句。</li><li>如果在关闭一个资源时抛出另一个异常，try-with-resources语句会重新抛出原来异常(try-catch语句块中的异常)。</li><li>反射操作的异常新增了一个公共的父类ReflectiveOperationException。</li><li>使用Path 接口来替代File类。</li><li>使用<code>Files</code>类的静态方法来读取，写入，删除，创建文件 以及创建目录。</li><li>使用<code>Objects.equals</code></li><li><code>Objects.hash</code></li></ul><h3 id="JavaScript引擎－Nashorn"><a href="#JavaScript引擎－Nashorn" class="headerlink" title="JavaScript引擎－Nashorn"></a>JavaScript引擎－Nashorn</h3><p>  <code>todo...</code></p><h3 id="JavaFX"><a href="#JavaFX" class="headerlink" title="JavaFX"></a>JavaFX</h3><p>  <code>todo...</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清明</title>
      <link href="/2016/04/04/%E6%B8%85%E6%98%8E/"/>
      <url>/2016/04/04/%E6%B8%85%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="清明时节雨纷纷"><a href="#清明时节雨纷纷" class="headerlink" title="清明时节雨纷纷"></a>清明时节雨纷纷</h3><p>清明，”十年生死两茫茫，不思量，自难忘”，祭祖扫墓怀亲，思念绵绵的清明。清明，“青梅如豆柳如眉，日长蝴蝶飞”，踏青游春休憩，意趣绵绵的清明。今天清明节，怀念下亲人，整理下自己。明日，带着一颗清洁而明净的心继续前行(这么文雅的词，说的我都不好意思了呢，其实是在央视新闻公众号上抄来的)。   </p><span id="more"></span><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="100" height="5" src="http://music.163.com/outchain/player?type=2&id=26418355&auto=1&height=66"></iframe><p>清明节，又称寒食节，大约始于周代，已有两千五百多年的历史。<a href="http://www.china.com.cn/ch-jieri/qingming/2.htm">清明节的由来与传说</a>。</p><p>本来打算这三天就待在房间里看书，撸一撸代码打打游戏的，可就坐了一上午就实在待不住了。第一天去找了下正在读研的大学同学，研没读完，孩子都有了。胡屁屁下厨整了一桌子菜，几个人吃吃喝喝，聊了好多。之前对研究生的生活还是满憧憬的，也有过一段时间犹豫过是否要考研。现在听他们一聊，我朝的高等教育也真是呵呵了。<br>第二天跟巩咪咪一起去了金牛湖，之所以去这鸟远的地方，其实最主要的还是听妹子推荐的(要是妹子一起去有多好)。本来是抱着看到大好风光的心情去的。没想到湖边的风还真是大，夹杂着水汽 两个人冻成狗。在门口犹豫了下到底要不要进去，还掷了硬币，正面朝上就进去，没想到连续两次正面朝上，还想掷第三次的，硬币不知滚哪去了。。看来是天意，好吧，门票又多了一块钱。转一一圈发现也没啥，就是一个人工湖，湖边有座山，山上有座庙，庙里并没有看到老和尚。山上面还有一个猴园。看了其实心里挺不舒服的。一大群的猴子被关在一个大笼子里，就只是为了让时而路过的人看两眼？<br>两天已过，按照剧情，假期最后一天都是要老老实实待着看看书收收心的。没想到今天天气竟然这么好，真实哔了狗了。中午吃完饭没事，想着最近视力感觉下降挺厉害的，就骑车跑到三江旁的眼镜店验了下光，结果是比自己想的要好些吧，要注意保护自己的眼睛了。</p><p>&#x2F;&#x2F;————4月5号晚乱入</p><p>有人说我这背景音乐配的有些不符场景，我说 谁叫我这人不懂音乐，所以 时而不靠谱，时而不着调呢，听到觉得好听就配上咯。。。刚才手贱看了下这歌的歌词，卧槽 好忧伤。我竟然还分享到了朋友圈😳。     </p><p>&#x2F;&#x2F;—————–乱入完</p><h3 id="季度小结"><a href="#季度小结" class="headerlink" title="季度小结"></a>季度小结</h3><p>时间真是快，2016年已经过去四分之一了。又去翻了下年初立下的几个目标，还好，我还在朝着这个方向努力。勿忘初心。</p><h3 id="金马奖最佳影片-十年"><a href="#金马奖最佳影片-十年" class="headerlink" title="金马奖最佳影片 - 十年"></a>金马奖最佳影片 - 十年</h3><p>昨天，35届香港金马奖颁奖。最佳电影是 <a href="https://zh.wikipedia.org/wiki/%E5%8D%81%E5%B9%B4_(%E9%9B%BB%E5%BD%B1)" target="_blank">十年</a>， 却被大陆全面封锁了。特地去了解了下这部电影。</p><p>这部电影由五个小故事组成。其中有四个牵扯到政治，难怪被大陆封杀了。关于这故事的内容，不敢妄加评断，仁者见仁，智者见者吧。</p><h3 id="再谈-‘清明’"><a href="#再谈-‘清明’" class="headerlink" title="再谈 ‘清明’"></a>再谈 ‘清明’</h3><p>本来要说说‘清明’这个话题的(并不是清明节的清明)。。。刚随便看看，Google到一大牛的博客，2005到现在写了十多年了。随便翻两篇文章，感觉差距啊。</p><p>无知大概可分为两种：言之无物 和 不知所云(不知道要说啥，怎么说)。我现在大概就处于不知所云的状态。明明想了两天的话题，怎么都憋不出顺溜的一段话。现在明白了，大概就是肚子里的货太少。还是要多看书啊。还好我还是属于有自知之明的人，最怕就是那种言之无物还老是叨逼叨  却不自知。    </p><p>关于读书，又想起前两天看到的一个话题，大致意思就是读书相对于 打游戏 就是个很高大上很有逼格的爱好吗？ 愚以为，读书也好，打游戏也好，都是个人的爱好，难道连个人爱好也要形成鄙视链了？对于大多数人来说，读书与打游戏都是消遣时间的方式，对于那些读书如走马观花，且不做笔记，不加思考的人，读了几个小时书，与打几个小时游戏有什么区别吗？当然不可否认，用心读书，从长远来看可能比游戏对个人的进益要大一些。但是不管怎么说，罗布白菜各有所爱吧。你喜欢就好。     </p><p>当然，写博客也是一个爱好，爱好不在多，最重要的是坚持。</p><p>做人嘛，最重要就是开心咯(我好像又跑题了)。。。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等待，是最极致的思念</title>
      <link href="/2016/03/25/%E7%AD%89%E5%BE%85%EF%BC%8C%E6%98%AF%E6%9C%80%E6%9E%81%E8%87%B4%E7%9A%84%E6%80%9D%E5%BF%B5/"/>
      <url>/2016/03/25/%E7%AD%89%E5%BE%85%EF%BC%8C%E6%98%AF%E6%9C%80%E6%9E%81%E8%87%B4%E7%9A%84%E6%80%9D%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h1><p>有人说，陪伴，是最长情的告白。<br>那么，等待，也许就是最极致的思念了吧。。。    </p><span id="more"></span><p>今天在知乎上看到的一个故事，觉得不错，特地向作者申请了下，得到许可转载过来。原文链接稍后给出，且听我把故事慢慢讲完…</p><h1 id="等待，是最极致的思念"><a href="#等待，是最极致的思念" class="headerlink" title="等待，是最极致的思念"></a>等待，是最极致的思念</h1><p>故事的开头，是一对父女于秋日的傍晚，在林间小路骑着单车。<br><img src="http://ww3.sinaimg.cn/large/a1d44fefgw1f29ys7bapsj20hs0dcmxr.jpg"></p><p>他们来到了岸边，父亲将要渡河。<br><img src="http://ww4.sinaimg.cn/large/a1d44fefgw1f29ysr8xk0j20hs0dc74p.jpg"><br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f29yuqa7c9j20hs0dcaak.jpg"></p><p>似乎预感到了什么，父亲又折了回来，抱起了自己的小女儿。<br><img src="http://ww2.sinaimg.cn/large/a1d44fefgw1f29yvdurzej20hs0dcgmc.jpg"></p><p>最后，父亲还是乘着小船离开了，只剩女儿呆呆地望着他远去的身影。<br><img src="http://ww3.sinaimg.cn/large/a1d44fefgw1f29yvow38tj20hs0dct92.jpg"><br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f29yw1xn1tj20hs0dcwev.jpg"></p><p>没想到，这一望就是一辈子。</p><p>父亲再也没有回来。可是女孩依旧每天来到岸边，等待着她的父亲。<br><img src="http://ww4.sinaimg.cn/large/a1d44fefgw1f29yx1r7dcj20hs0dcmxv.jpg"><br><img src="http://ww3.sinaimg.cn/large/a1d44fefgw1f29yxwhmvej20hs0dc0tf.jpg"></p><p>小女孩长大了，成了婷婷而立的少女。她依旧每天来到岸边，父亲的自行车也依旧停靠在树下，就像刚离开时的那样。<br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f29yy9em3xj20hs0dcwez.jpg"><br><img src="http://ww4.sinaimg.cn/large/a1d44fefgw1f29yymh6wmj20hs0dc3z6.jpg"></p><p>不知道过了多久，父亲的自行车已经消失不见，女孩也长大成了青年。她依旧像小时候那样，每天来到岸边，等待着她的父亲。<br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f29yz615ydj20hs0dct90.jpg"><br><img src="http://ww2.sinaimg.cn/large/a1d44fefgw1f29yzoy3ioj20hs0dcmy1.jpg"></p><p>就算与闺蜜出游，路过的时候，也依旧会驻足。<br><img src="http://ww3.sinaimg.cn/large/a1d44fefgw1f29z07dabvj20hs0dc0te.jpg"><br><img src="http://ww4.sinaimg.cn/large/a1d44fefgw1f29z0mpwp6j20hs0dcaam.jpg"></p><p>不知过了多久，女孩终于找到了心上人。她不再自己一个人骑车，而是由她的男友骑车带着她。<br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f29z14auxsj20hs0dcaao.jpg"></p><p>女孩并没有告诉男友关于她父亲的事，他们经过岸边的时候，没有停下来，但她依然会转头瞭望。<br><img src="http://ww3.sinaimg.cn/large/a1d44fefgw1f29z1v1o4rj20hs0dcjro.jpg"></p><p>她结了婚，有了一双儿女。这次，他们一家四口骑车来到河岸边游玩。<br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f29z2cw4f0j20hs0dcjrz.jpg"></p><p>丈夫望着河面百无聊赖，儿女在河边嬉戏。而她却伫立在岸上，眺望着远方，就像小时候那样。<br><img src="http://ww3.sinaimg.cn/large/a1d44fefgw1f29z2s8yi2j20hs0dc0sz.jpg"><br><img src="http://ww3.sinaimg.cn/large/a1d44fefgw1f29z35tcuej20hs0dcq38.jpg"></p><p>时光飞梭，女孩再也不年轻了，但却依然会每天来岸边等待父亲。虽然，她知道永远等不到了。<br><img src="http://ww4.sinaimg.cn/large/a1d44fefgw1f29z3wifqmj20hs0dc75k.jpg"></p><p>也许是时间太久了，她发现，不知道什么时候，河流已经干涸，化为了滩涂。<br><img src="http://ww4.sinaimg.cn/large/a1d44fefgw1f29z4d7z91j20hs0dc74t.jpg"><br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f29z4rm8aoj20hs0dcq3d.jpg"></p><p>又过了很多年，女孩已经垂垂老矣，老到都骑不了车了。于是她推着自行车，像往常一样，来到岸边。<br><img src="http://ww2.sinaimg.cn/large/a1d44fefgw1f29z5aek43j20hs0dcq3e.jpg"></p><p>她想把自行车停在岸边，可是自行车也老了，甚至都立不起来。<br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f29z5s0itlj20hs0dct97.jpg"><br><img src="http://ww2.sinaimg.cn/large/a1d44fefgw1f29z64cfemj20hs0dcgm4.jpg"></p><p>沧海桑田。当初的河流，如今已成了草原。<br><img src="http://ww4.sinaimg.cn/large/a1d44fefgw1f29z6iogw5j20hs0dcdg2.jpg"></p><p>于是，她决定穿过草丛去寻找父亲。<br><img src="http://ww4.sinaimg.cn/large/a1d44fefgw1f29z6zykcxj20hs0dc0st.jpg"></p><p>在草丛的中央，她发现了一艘沉船。那正是她父亲的小船。<br><img src="http://ww4.sinaimg.cn/large/a1d44fefgw1f29z7hf0hej20hs0dcq3p.jpg"><br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f29z7yxscmj20hs0dcab5.jpg"></p><p>她缓缓地走过去，抚摸着小船，轻轻地躺在小船里，就像当初躺在父亲的臂弯中一样。<br><img src="http://ww4.sinaimg.cn/large/a1d44fefgw1f29z8h43h7j20hs0dcgmr.jpg"></p><p>在生命的最后时刻，她似乎听见了自己父亲的呼唤。<br><img src="http://ww2.sinaimg.cn/large/a1d44fefgw1f29z8x845gj20hs0dct9b.jpg"></p><p>她起身向那前方奔去。她欢快地跑着，越变越年轻，越变越小。<br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f29z9c342pj20hs0dcweo.jpg"><br><img src="http://ww2.sinaimg.cn/large/a1d44fefgw1f29z9qj6eyj20hs0dcjrj.jpg"><br><img src="http://ww2.sinaimg.cn/large/a1d44fefgw1f29za3egaqj20hs0dcq33.jpg"></p><p>终于，她见到了自己的父亲。<br><img src="http://ww3.sinaimg.cn/large/a1d44fefgw1f29zamirm2j20hs0dcaad.jpg"></p><p>这个等待了一辈子的女孩，终于等到了那个久违的，温暖的怀抱。<br><img src="http://ww2.sinaimg.cn/large/a1d44fefgw1f29zb3bjumj20hs0dcdg5.jpg"></p><p>故事结束了…</p><p>看完这个故事，我也想到了自己的父亲。。想起来曾经干过的傻事。还有…  </p><p>你呢？</p><p>虽然很残酷，但我们都知道，女孩最后所见，只是她垂死之时的幻觉。她父亲早在最初就已沉船身亡，她此后一生的等待都是徒劳无功的。可是，就算给她最来过一次的机会，我想她还是会这样傻傻的等下去吧。。。</p><p>** 可是，等待是痛苦的，谁都不希望会有这样漫长的等待，所以，珍惜当下，珍惜身边人。。。 **</p><p>这个故事是一部动画短片，片名《父与女》【<a href="https://movie.douban.com/subject/1300395/">豆瓣</a> ｜<a href="https://movie.douban.com/review/5339833/">豆瓣解读</a>｜<a href="https://www.youtube.com/watch?v=vITbTj5Z3-8">youtube链接</a>】，豆瓣得分9.2分，并获得了第73届奥斯卡金像奖最佳动画短片奖。<br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f29zc4kq85j20go099wfw.jpg"></p><p><strong>这个是<a href="https://www.zhihu.com/question/31914864/answer/88492843">原文地址</a>：<a href="https://www.zhihu.com/question/31914864">思念到极致是什么感觉</a>，<a href="https://www.zhihu.com/question/31914864/answer/88492843">Pein融的答案</a></strong></p><p>我喜欢听音乐，恨不得每篇文章都给配上音乐。可是这篇文章却没敢给配，觉得还是安静着看完比较好，音乐容易影响人的思维。每个人看完会有不一样的体会吧。</p><p>就酱。。。晚安😊</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 故事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性概览(三)</title>
      <link href="/2016/03/23/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88(%E4%B8%89)/"/>
      <url>/2016/03/23/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>最近在知乎上看到个话题，觉得挺有意思。<a href="https://www.zhihu.com/question/22633562">不浮躁的社会是什么样的？</a>(看完了，反省下自己，别浮躁)。尤其看到<a href="https://www.zhihu.com/question/22633562/answer/90351145">这个答案</a>的时候，真是被触动到了，由衷的对这个老师感到敬佩。其实，我的梦想之一就是有了足够的钱去建所学校(认真脸)…</p><span id="more"></span><h3 id="使用lambda编程"><a href="#使用lambda编程" class="headerlink" title="使用lambda编程"></a>使用lambda编程</h3><ul><li>使用lambda表达式的主要原因是，将代码的执行延迟到一个合适的时间点。</li><li>当执行一个lambda表达式时，请确认提供了所有必须的参数作为输入。</li><li>如果可以，请选择一个已有的函数式接口。</li><li>编写一个返回函数式接口实例的方法通常很有用。</li><li>当你使用转换时，请考虑如何能组合它们。</li><li>要延迟组合转换，你需要保留一个所有未执行的转换列表，并在最后应用它们。</li><li>如果你需要多次应用一个lambda表达式，最好将工作分成多个子任务，以便可以并发执行。</li><li>考虑如何处理lambda表达式中抛出异常的情况。</li><li>当使用泛型函数式接口时，请使用<code>? Super</code>通配符作为参数类型，使用<code>? Extend</code>通配符作为返回类型。</li><li>当使用可以被函数转换的泛型类型时，请考虑使用map和flatMap。</li></ul><h4 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h4><p>lambda表达式都是 <strong>延迟执行</strong> 的。</p><p>延迟执行的原因有很多，例如：  </p><ol><li>在另一个线程中运行代码。</li><li>多次运行代码。</li><li>在某个算法的正确时间上运行代码(例如排序中的比较操作)</li><li>当某些情况发生时运行代码(按钮被点击，数据到达等)</li><li>只有在需要的时候才运行的代码</li></ol><p>例如，在记录INFO级别的日志时</p><pre><code>public static void info(Logger logger, Supplier&lt;String&gt; message)&#123;    if(logger.isLoggable(Level.INFO))&#123;//当日志级别INFO开启时      logger.info(message.get());    &#125;&#125;</code></pre><h4 id="选择一个函数式接口"><a href="#选择一个函数式接口" class="headerlink" title="选择一个函数式接口"></a>选择一个函数式接口</h4><ul><li>常用函数式接口</li></ul><p>| 函数式接口 | 参数类型  | 返回类型    | 抽象方法名  | 描述  | 其他方法<br>| :————- | :————- |<br>| Runnable       | 无      | void   | run |  执行一个没有参数和返回值的操作|  -  |<br>| <code>Supplier&lt;T&gt;</code>    | 无      |  T   | get  | 提供一个T类型的值|  - |<br>| <code>Consumer&lt;T&gt;</code>    | T       |  void   | accept  |  处理一个T类型的值 |  chain |<br>| <code>BiConsumer&lt;T, U&gt;</code>| T, U  | void     | accept  | 处理一个T类型和U类型的值 | chain |<br>| <code>Function&lt;T, R&gt;</code>  | T     |  R       | apply   | 一个参数类型为T返回值类型为R的函数| compose,andThen,identity|<br>| <code>BiFunction&lt;T, U, R&gt;</code>| T, U | R  |  apply  | 一个参数类型为T和U返回值类型为R的函数  |  andThen|<br>| <code>UnaryOperator&lt;T&gt;</code> | T  |   T  |  apply  |  对类型T进行一元操作 |  compose, andThen, identity|<br>| <code>BinaryOperator&lt;T&gt;</code>| T, T | T  | apply |  对类型T进行的二元操作 | andThen|<br>| <code>Predicate&lt;T&gt;</code>    | T  | boolean | test | 一个计算Boolean值的函数| And, or, negate, isEqual|<br>| <code>BiPredicate&lt;T, U&gt;</code>| T, U| boolean | test| 一个根据T、U类型参数计算boolean值得函数| And, or, negate|</p><ul><li><p>为原始类型提供的函数式接口</p><p>当然，API还提供了为原始类型提供的函数式接口。<br>例如返回 boolean的 BooleanSupplier接口。提供Int值的IntSupplier，消费Int值的IntConsumer。Int转double的IntToDoubleFunction。</p></li><li><p>自己动手写一个函数式接口<br>自己动手写一个函数式接口：<br>允许用户指定的一个函数 (int, int, Color) -&gt; Color，根据图片中(x, y)位置上的像素来计算新的颜色   </p><p>  @FunctionalInterface<br>  public interface ColorTransformer {<br>  Color apply(int x, int y, Color colorAtXY);<br>  }</p></li></ul><h4 id="返回函数与组合"><a href="#返回函数与组合" class="headerlink" title="返回函数与组合"></a>返回函数与组合</h4><pre><code>public static &lt;T&gt; UnaryOperator&lt;T&gt; compose(UnaryOperator&lt;T&gt; op1, UnaryOperator&lt;T&gt; op2)&#123;  return t -&gt; op2.apply(op1.apply(t));&#125;</code></pre><h4 id="延迟与并行操作"><a href="#延迟与并行操作" class="headerlink" title="延迟与并行操作"></a>延迟与并行操作</h4><p><code>todo...</code></p><h4 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h4><ul><li><p>提供一个异常处理的handler</p><pre><code>&lt;T&gt; void doInOrderAsync(Supplier&lt;T&gt; first, Consumer&lt;T&gt; second, Consumer&lt;Throwable&gt; handler)&#123;  Thread t = new Thread(new Runnable() &#123;      @Override      public void run() &#123;          try &#123;              T t = first.get();              second.accept(t);          &#125; catch (Exception e) &#123;              handler.accept(e);          &#125;      &#125;  &#125;);  t.start();&#125;</code></pre></li></ul><h4 id="lambda表达式和泛型"><a href="#lambda表达式和泛型" class="headerlink" title="lambda表达式和泛型"></a>lambda表达式和泛型</h4><p><strong>一般准则是父类作为参数类型，子类作为返回类型</strong> ，这样，可以将一个<code>Consumer&lt;Object&gt;</code> 传递给一个 <code>Stream&lt;String&gt;</code>的forEach方法。可以处理Object，也就是任何对象，当然也包括String咯。<br>这样刚才的doInOrderAsync方法的入参应如下：<br><code>void doInOrderAsync(Supplier&lt;? extends T&gt; first, Consumer&lt;? super T&gt; second, Consumer&lt;? super T&gt; handler)</code></p><h3 id="新的日期和时间API"><a href="#新的日期和时间API" class="headerlink" title="新的日期和时间API"></a>新的日期和时间API</h3><ul><li>所有java.time对象都是不可变的</li><li>一个瞬间(Instant)是时间线上的一个点(与Date类似)</li><li>在Java事件中，每天都是86400秒(即没有闰秒)</li><li>持续时间(Duration)是两个瞬间之间的时间</li><li>LocalDateTime没有时区信息</li><li>TemporalAdjuster 的方法可以处理常用的日历计算，例如找到某个月的第一个星期二</li><li>ZonedDateTime 是指定时区中的某一个时间点(类似于Gregorian Calendar)</li><li>单处理带时区的时间时，请使用时段(Period)，而非 Duration，以便将夏令时的变化考虑在内</li><li>使用DateTimeFormatter 来格式化日期和时间</li></ul><h4 id="时间点与时间段"><a href="#时间点与时间段" class="headerlink" title="时间点与时间段"></a>时间点与时间段</h4><p>  在java中有如下时标：</p><ol><li>每天都有86400秒</li><li>每天正午与官方时间准确匹配</li><li>其他时间也要以一种精确定义的方式与其紧密匹配</li></ol><p>Java8中引入的时间点与持续时间</p><ul><li><p><code>Instant</code>：一个instant对象表示时间轴上的一个点。<br>时间原点被规定为1970年1月1日的午夜，此时本初子午线正在穿过伦敦格林尼治皇家天文台。</p><ul><li><code>Instant.MIN</code> 表示10亿年前。</li><li><code>Instant.MAX</code> 表示10 0000 0000 年的12月31日。</li><li><code>Instant.now()</code>会返回当前的瞬间点。</li></ul></li><li><p><code>Duration</code> : 两个时间点之前的时间量   </p><pre><code>Instant start = Instant.now();runAlgorithm();Instant end = Instant.now();Duration timeElapsed = Duration.between(start, end);long millis = timeElapsed.toMillis();</code></pre></li><li><p><code>Period</code> 时段：表示一段逝去的年、月 或 日</p></li><li><p>Instant与Duration的其他操作见API</p></li></ul><h4 id="本地日期-LocalDate"><a href="#本地日期-LocalDate" class="headerlink" title="本地日期(LocalDate)"></a>本地日期(LocalDate)</h4><p>  <code>LocalDate</code> 是一个带有年份，月份，当月天数的日期。</p><ul><li>创建LocalDate<ul><li><code>LocalDate today = LocalDate.now(); //今天的日期</code></li><li><code>LocalDate alonzosBirthday = LocalDate.of(1903, 6, 14);</code><br><code>alonzosBirthday = LocalDate.of(1903, Month.JUNE, 14); //使用Month枚举</code></li></ul></li></ul><h4 id="日期矫正器"><a href="#日期矫正器" class="headerlink" title="日期矫正器"></a>日期矫正器</h4><p>  对于一些需要安排调度的应用程序，通常需要计算例如“每月的第一个周二”这样的日期。<code>TemporalAdjusters</code>类提供了许多静态方法来进行常用的矫正。你可以将一个矫正方法的结果传递给with方法。例如，你可以通过如下代码来计算某个月第一个周二：    </p><pre><code>    LocalDate firstTuseDay = LocalDate.of(year, month, 1).with(TemporalAdjusters.nextOrSame(DayOfWeek.TUESDAY));</code></pre><h4 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h4><p>  LocalTime 表示一天中的某个时间，例如 15:30:00。你可以使用now或者of方法来创建一个LocalTime实例。</p><pre><code>    LocalTime rightNow = LocalTime.now();    LocalTime bedtime = LocalTime.of(22, 30);// 或者LocalTime.of(22, 30, 00);</code></pre><h4 id="带时区的时间"><a href="#带时区的时间" class="headerlink" title="带时区的时间"></a>带时区的时间</h4><p>  <code>ZonedDateTime</code></p><ul><li>localDateTime.atZone(zoneId)</li><li>ZonedDateTime.of(1969, 7, 16, 9, 32, 0, 0, ZoneId.of(“America&#x2F;New_York”));</li></ul><h4 id="格式化和解析-DateTimeFormatter"><a href="#格式化和解析-DateTimeFormatter" class="headerlink" title="格式化和解析 DateTimeFormatter"></a>格式化和解析 <code>DateTimeFormatter</code></h4><p>  提供了三种方法来格式化打印日期&#x2F;时间：</p><ul><li>预定义的标准格式</li><li>语言环境相关的格式</li><li>自定义的格式<br><code>DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);</code></li></ul><h3 id="并发增强"><a href="#并发增强" class="headerlink" title="并发增强"></a>并发增强</h3><ul><li>使用<code>updateAndGet/accumulateAndGet</code>方法可以更容易的更新原子变量</li><li>在激烈的竞争环境下，<code>LongAccumulator/DoubleAccumulator</code>比<code>AtomicLong/AtomicDouble</code>效率更高</li><li>使用<code>compute/merge</code>方法可以更容易的更新<code>ConcurrentHashMap</code>中的元素项</li><li>ConcurrentHashMap提供了对键、值、键值对 及各元素项的各类操作，例如：search、reduce、forEach</li><li>集合视图允许将ConcurrentHashMap作为一个Set来使用</li><li>Arrays 类提供了排序、填充 及前缀操作的并行方法</li><li>完善的Future 类允许你创建异步的操作</li></ul><h4 id="原子值"><a href="#原子值" class="headerlink" title="原子值"></a>原子值</h4><p>在Java5中提供了 java.util.concurrent包，为我们提供了线程安全的集合和线程池，以及很多其他的并发工具。<br>在Java8之前常见的 CAS(compare and swap)加自旋来更新一个原子量：</p><pre><code>  public static AtomicLong largest = new AtomicLong();  do &#123;    oldValue = largest.get(); //获得当前值    newValue = Math.max(oldValue, observed); // observed 观测值  &#125; while (!largest.compareAndSet(oldValue, newValue));</code></pre><p>在Java8中，可以通过 <code>updateAndGet(LongUnaryOperator updateFunction)/getAndAccumulate(long x, LongBinaryOperator accumulatorFunction)</code>，来更方便的实现这个操作：</p><pre><code>  largest.updateAndGet(x -&gt; Math.max(x, observed));  //或  largest.getAndAccumulate(observed, Math::max);</code></pre><p>当有大量线程访问同一个原子值时，偶遇乐观锁更新需要太多次重试，因此会导致性能严重下降。为此Java8提供了<code>LongAdder</code>和<code>LongAccumulator</code>来解决该问题。LongAdder由多个变量组成，这些变量会自动增加新的被加数。由于通常情况下都是知道所有工作完成后才需要总和值，所以这种方法效率很高。</p><p>如果你的环境中存在高度竞争，那么就应该用LongAdder 来替代 AtomicLong。 在LongAdder中，<code>increment()</code>方法用来将计数器自增1，<code>add</code>方法用来加上某个数值，<code>sum</code>方法用来获取总和值。</p><pre><code>  final LongAdder adder = new LongAdder();  for(...)&#123;    pool.submit(() -&gt; &#123;      while(...)&#123;        ...        if (...) adder.increment(); //自增1      &#125;    &#125;);  &#125;  ...  long total = adder.sum();</code></pre><p>关于LongAdder的实现，可以参看<a href="http://coolshell.cn/articles/11454.html">从LongAdder看更高效的无锁实现</a>。</p><p>LongAccumulator 将这个思想带到了任意的累加操作中。在构造函数中，你需要提供操作类型及其中的中立元素。要与新值相加，需要调用accumulate方法。然后调用 get 方法获取当前值。以下代码与 LongAdder 的效果是一样的：</p><pre><code>  LongAccumulator adder = new LongAccumulator(Long::sum, 0);  //在某些线程中  adder.accumulate(value);</code></pre><p>在 LongAccumulator 的内部，包含 a1,a2,a3,…an等多个变量。每个变量都被初始化为中立元素(在上面的例子中即为0)。<br>当调用 accum 方法累加值V时，这些变量其中之一会自动被更新为 <code>ai = ai op v</code>，其中op是以中缀形式表示的累加操作。在上面的实例中，调用accumulate会对变量i计算 ai &#x3D; ai+v。 get 方法的结果为 a1<code>op</code>a2<code>op</code>a3<code>op</code>…<code>op</code>an。在上面的例子中，它会计算所有变量的总和，即 a1+a2+…+an。</p><p>Java8中新增了一个<code>StampedLock</code>类，用来实现乐观读。</p><pre><code>    public class Vector&#123;      private int size;      private Object[] elements;      // 实现乐观读      private StampedLock lock = new StampedLock();      public Object get(int n)&#123;        //1.获得一个 印戳        long stamp = lock.tryOptimisticRead();        //2.读取值        Object[] currentElements = elements;        int currentSize = size;        //3.检查印戳 是否仍然有效        if (!lock.validate(stamp))&#123;          //4. 印戳无效，获得一个读锁(将会阻塞所有的写锁)          stamp = lock.readLock();          //5. 在此读取值          currentElements = elements;          currentSize = size;          //6. 释放读锁          lock.unlockRead(stamp);        &#125;        return n &lt; currentSize ? currentElements[n] : null;      &#125;      ...    &#125;</code></pre><h4 id="ConcurrentHashMap-改进"><a href="#ConcurrentHashMap-改进" class="headerlink" title="ConcurrentHashMap 改进"></a>ConcurrentHashMap 改进</h4><p>compute方法与merge方法</p><h5 id="更新值"><a href="#更新值" class="headerlink" title="更新值"></a>更新值</h5><p>先看一个非线程安全的更新值的例子A：</p><pre><code>  Long oldValue = map.get(word);  Long newValue = oldValue == null ? 1 : oldValue + 1;  map.put(word, newValue); //错误</code></pre><p>为什么非线程安全？因为这个<code>取值，加值，更新值</code>并不是一个原子操作。可以通过使用 <code>replace</code>加自旋来进行这个操作：</p><pre><code>  do &#123;    oldValue = map.get(word);    newValue = oldValue == null ? 1 : oldValue + 1;  &#125; while (!map.replace(word, oldValue, newValue));</code></pre><p>另外，可以使用AtomicLong或者LongAdder 实现上述功能。</p><pre><code>  map.putIfAbsent(word, new LongAdder()); // 确保 word键值对存在  map.get(word).increment();  //由于putIfAbsent方法会返回映射值，可以将这两条语句合并为一条：  map.putIfAbsent(word, new LongAdder()).increment();</code></pre><p>Java8 中 <code>compute</code> 方法可以通过一个键和一个函数来计算出新的值。该函数会获取键及其相关的值(如果没有值则为null)，然后计算出新的值。</p><pre><code>  map.compute(word, (k, v) -&gt; v == null ? 1 : v + 1);</code></pre><p>Java8中还提供了<code>computeIfPresent</code>和<code>computeIfAbsent</code>方法，分别在值存在 和 值尚未村阿紫的情况下，才计算新值。因此，还可以这样写</p><pre><code>  map.computeIfAbsent(word, k - &gt; new LongAdder()).increment(); // 值尚未存在的时候，设置一个 新的 LongAdder</code></pre><p><code>merge</code>方法更新值</p><pre><code>  map.merge(word, 1L, (existingValue, newValue) -&gt; existingValue + newValue); // 参数 1L 表示，键尚未存在时的值。  // 或  map.merge(word, 1L, Long::sum); // 还记得lambda中的构造器引用吗。</code></pre><p>注意：<br>    1. 如果传递给<code>compute</code>或<code>merge</code>方法的函数返回null，那么有的数据项会从映射中删除掉。<br>    2. <code>compute</code>和<code>merge</code>方法运行时，其他一些更新映射的操作可能会被阻塞。所以，最好不要在 提供给这两个方法的函数中进行大量的工作。</p><h5 id="批量数据操作"><a href="#批量数据操作" class="headerlink" title="批量数据操作"></a>批量数据操作</h5><p>Java 8 为ConcurrentHashMap提供了批量数据操作，即使是在其他线程同时操作映射时也可以安全的执行。批量数据操作会遍历映射并对匹配的元素进行操作。</p><p>批量数据操作有三类：</p><ul><li>search 会对每个键和(或)值应用一个函数，直到该函数返回一个null的结果。然后search会终止并返回该函数的结果。</li><li>reduce 会通过提供的累积函数，将所有的键和(或)值组合起来。</li><li>forEach 会对所有键和(或)值应用一个函数。</li></ul><p>每个操作都有下面4个版本：</p><ul><li>searchKeys&#x2F;reduceKeys&#x2F;forEachKeys：对键操作</li><li>searchValues&#x2F;reduceValues&#x2F;forEachValues：对值操作</li><li>search&#x2F;reduce&#x2F;forEach：对键和值操作</li><li>searchEntries&#x2F;reduceEntries&#x2F;forEachEntries：对Map.Entry对象操作</li></ul><p>在使用这四个操作时，需要指定一个并行阀值。如果映射包含的元素数量超过了这个阀值，批量操作就以并行方式执行。</p><p>以search方法为例，来看上面的四个版本：</p><ul><li>U searchKeys(long threshold, Function&lt;? super K, ? extends U&gt; f)</li><li>U searchValues(long threshold, Function&lt;? super K, ? extends U&gt; f)</li><li>U search(long threshold, BiFunction&lt;? super K, ? super V, ? extends U&gt; f)</li><li>U searchEntries(long threshold, Function&lt;Map.Entry&lt;K, V&gt;, ? extends U&gt; f)</li></ul><p>注：书上的searchKeys,searchValues,searchEntries三处的函数接口写成了BiFunction，在这里显然是不对的，因为只有一个入参，应该是Function接口，查阅Oracle API文档确实如此，在这里要纠正下。不知道是原作者写错了，还是翻译成中文的时候写错了，还是印刷错误。。想给原作者的站点去反馈的，可是感觉英文表达好费劲。。。不管怎样还是被自己的机智所感动啊。恩，看书，要有自己的想法，有所思。</p><p>例如，假设我们希望找到第一个出现超过1000次的单词，我们需要搜索键和值：</p><pre><code>  String result = map.search(threshold, (k, v) -&gt; v &gt; 1000 ? k : null);</code></pre><p>forEach 方法有两种形式，第一种只是对每个映射数据项简单的应用一个消费者函数：</p><pre><code>  map.forEach(threshold, (k, v) -&gt; System.out.println(k + &quot; -&gt; &quot; + v));</code></pre><p>第二种形式会额外的接受一个转换器函数，首先会应用该转换器函数，然后再将其结果传递给消费者函数：</p><pre><code>  map.forEach(threshold,  //并行阀值                (k, v) -&gt; k + &quot; -&gt; &quot; + v, // 转换器函数                System.out::println); // 消费者函数</code></pre><p>转换器函数可以被用作一个过滤器。当转换器函数返回null时，值会被直接跳过。</p><p>例如，我们可以使用如下代码打印值较大的数据项：</p><pre><code>  map.forEach(threshold,                (k, v) -&gt; v &gt; 1000 ? k + &quot; -&gt; &quot; + v : null,  // 转换器同时具有过滤器的功能                  System.out::println); // 消费者函数</code></pre><p>reduce 操作将其输入与一个累加函数结合起来。例如，下面的代码展示了如何计算所有值的总和：</p><pre><code>  Long sum = map.reduceValues(threshold, Long::sum);</code></pre><p>同forEach一样，你也可以提供一个转换器函数。我们这里计算最长键的长度：</p><pre><code>  Integer maxLength = map.reduceKeys(threshold,                                      String::length,   // 转换器，将String转换为Integer，作为消费者函数的输入                                      Integer::max);    // 消费者，消费转换器的结果</code></pre><p>转换器可以作为一个过滤器，通过返回null，来排除不想要的输入。这里，我们计算大于1000的数据项的个数：</p><pre><code>  Long count = map.reduceValues(threshold,                                    v -&gt; v &gt; 1000 ? 1L : null,  // 带有过滤功能的转换器，过滤掉小于1000的数据项                                    Long::sum);  // 消费者函数</code></pre><h5 id="Set视图"><a href="#Set视图" class="headerlink" title="Set视图"></a>Set视图</h5><ul><li><p>newKeySet<br>  静态方法newKeySet 会返回一个 Set<K>对象，它实际上就是对 ConcurrentHashMap&lt;K, Boolean&gt; 对象的封装(所有映射的值都是Boolean.TRUE)。<br>  <code>Set&lt;String&gt; words = ConcurrentHashMap.&lt;String&gt;newKeySet();</code></p></li><li><p>keySet<br>  如果你已经有了一个map，那么keySet会返回所有键的Set。该Set是可变的。如果你删除该Set中的元素，那么相应的键(以及它的值)也会从映射中删除。但是你无法向这个键Set中添加元素，因为无法添加相应的值。于是Java8 又给ConcurrentHashMap添加了另一个keySet方法，它可以接受一个默认值，以使用与向Set中添加元素。</p><pre><code>      Set&lt;String&gt; words = map.keySet(1L);      words.add(&quot;Java&quot;);</code></pre><p>  如果words中尚未存在”Java”，那么它当前有一个值，为1。</p></li></ul><h4 id="并行数组操作"><a href="#并行数组操作" class="headerlink" title="并行数组操作"></a>并行数组操作</h4><ul><li><p>Arrays.parallelSort(words)  并行排序</p></li><li><p>Arrays.parallelSetAll  将数组中的值按照一个函数的计算结果过滤出来。改函数会获得元素索引，并计算该位置处的值<br>  <code>Arrays.parallelSetAll(values, i -&gt; i % 10) // values的值将被设置为0 1 2 3 4 5 6 7 8 9 10 0 1 2 ...</code></p></li><li><p>Arrays.parallelPrefix  将数组中的每个元素替换为指定关联操作的前缀的累积</p><pre><code>  int [] values = new int[] &#123;1, 2, 3, 4, 5, 6, 7, ... &#125;;  // 排序后数组的值为：[1, 1 * 2, 1 * 2 * 3, 1 * 2 * 3 * 4, ...]  Arrays.parallelPrefix(values, (x, y) -&gt; x * y);</code></pre></li></ul><h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><h5 id="回顾下Future"><a href="#回顾下Future" class="headerlink" title="回顾下Future"></a>回顾下<code>Future</code></h5><p>假设有如下方法：<br><code>public Future&lt;String&gt; readPage(URL url)</code><br>该方法会在一个单独的线程中读取一个网页，这一个过程需要花费一点时间。当你调用<br><code>Future&lt;String&gt; contents = readPage(url);</code><br>时，改方法会立即返回，同时你持有一个Future<String>对象。假设现在我们希望从页面中提取所有的URL，从而构建一个Web爬虫。现在我们有一个名为Parser的类，其中含有一个方法：<br><code>public static List&lt;URL&gt; getLinks(String page);</code><br>如何从上面得到的Future<String>中应用这个getLinks方法呢？只有一种方式，就是调用Future的get方法获取结果，然后调用getLinks方法：     </p><pre><code>    String page = contents.get();    List&lt;URL&gt; links = Parser.getLinks(page);</code></pre><p>但是这时，调用get会被阻塞，直到readPage 方法完成，Future中存在可用结果。</p><h5 id="使用CompletableFuture"><a href="#使用CompletableFuture" class="headerlink" title="使用CompletableFuture"></a>使用<code>CompletableFuture</code></h5><p>让我们对上面的readPage方法做些改动，使它返回一个 CompletableFuture<String> 对象。与普通Future对象不同，CompletableFuture对象拥有一个<code>thenApply</code>方法，你可以把进行后续处理的函数传递给它。     </p><pre><code>    CompletableFuture&lt;String&gt; contents = readPage(url);    CompletableFuture&lt;List&lt;String&gt;&gt; links = contents.thenApply(Parser::getLinks);</code></pre><p>thenApply 方法不会被阻塞。它会立刻返回另一个Future对象。当第一个Future对象完成时，它的结果会发给getLink方法，然后该方法的返回值会成为最终的结果。</p><h5 id="Future-流水线"><a href="#Future-流水线" class="headerlink" title="Future 流水线"></a>Future 流水线</h5><p>在前面，我们已经了解到一个Stream 流水线的过程，由创建流开始，然后经过一个或多个转换过程，最后由一个终止操作结束。Future 对象的流水线也是这样。</p><ul><li>创建 CompletableFuture 对象<br> 创建CompletableFuture对象通常都是由静态方法 <code>supplyAsync</code> 来完成。该方法需要一个 Supplier<T> 参数，即一个无参数、返回类型 T 的函数。该函数会在另一个线程中被调用。<br> 仍使用上面的例子：<code>CompletableFuture&lt;String&gt; contents = CompletableFuture.supplyAsync(() -&gt; blockingReadPage(url));</code><br> CompletableFuture还有一个静态方法<code>runAsync</code>，它接受一个Runnable 对象作为参数，返回一个CompletableFuture<Void>对象。当你只是想一个接一个地执行操作，而不需要在操作之前传递数据时，可以使用该方法。</li><li>运行接下来的操作<br>  接下来，你可以使用 <code>thenApply</code> 或 <code>theApplyAsync</code> 方法，在<code>同一个线程</code>或<code>另一个线程中</code>运行另一个操作。不管使用哪个方法，你都需要提供一个函数，并且会得到一个 CompletableFuture<U> 对象，其中 U 表示函数的返回类型。<br>  <code>CompletableFuture&lt;List&lt;String&gt;&gt; links = CompletableFuture.supplyAsync(() -&gt; blockingReadPage(url)).thenApply(Parser::getLinks);</code></li><li>处理结果<br>  <code>thenAccept</code> 方法接受一个 <code>Consumer</code> 函数 – 即一个返回类型为 void 的函数。<br>  <code>CompletableFuture&lt;Void&gt; links = CompletableFuture.supplyAsync(() -&gt; blockingReadPage(url)).thenApply(Parser::getLinks).thenAccept(System.out::println);</code></li></ul><h5 id="编写异步操作"><a href="#编写异步操作" class="headerlink" title="编写异步操作"></a>编写异步操作</h5><p>为了使用 CompletableFuture ，Java8提供了大量的方法。    </p><ul><li>处理单个 Future 的方法</li></ul><table><thead><tr><th align="left">方法</th><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">thenApply</td><td align="left">T -&gt; U</td><td align="left">为结果提供一个函数</td></tr><tr><td align="left">thenCompose</td><td align="left">T -&gt; CompletableFuture<U></td><td align="left">对结果调用一个函数，并执行返回的 Future 对象</td></tr><tr><td align="left">handle</td><td align="left">(T, Throwable) -&gt; U</td><td align="left">处理结果或者错误</td></tr><tr><td align="left">thenAccept</td><td align="left">T -&gt; void</td><td align="left">同 thenApply 类似，但是结果为void类型</td></tr><tr><td align="left">whenComplete</td><td align="left">(T, Throwable) -&gt; void</td><td align="left">同handle类似 但是结果为void类型</td></tr><tr><td align="left">thenRun</td><td align="left">Runnable</td><td align="left">执行返回void的Runnable对象</td></tr></tbody></table><ul><li>组合多个对象</li></ul><p>| 方法     | 参数     |  描述<br>| :————- | :————- |<br>| thenCombine   | CompletableFuture<U>, (T, U) -&gt; V      | 执行两个对象，并将结果按照指定的函数组合起来<br>| thenAcceptBoth| CompletableFuture<U>, (T, U) -&gt; void   | 同thenCombine 类似，但是结果为void类型<br>| runAfterBoth | CompletableFuture<?>, Runnable  | 在两个对象完成后，执行Runnable对象| applyToEither| CompletableFuture<T>, T -> V | 当其中一个对象的结果可用时，将结果传递给指定的函数| acceptEither | CompletableFuture<T>, T -> void | 同applyToEither 类似，但是结果为void类型| runAfterEither| CompletableFuture<?>, Runnable | 在其中一个对象结束后，执行Runnable对象<br>| static allOf | CompletableFuture<?>... | 在所有的Future对象结束后，并返回void结果| static anyOf | CompletableFuture<?>… | 在任何一个Future对象结束后，并返回void结果</p><p>前三个方法会并行运行一个 CompletableFuture<T>(也就是方法的调用者)和一个 CompletableFuture<U>(方法的参数Future) 操作，并将结果组合(就是第二个函数参数)到一起。<br>接下来三个方法会并行运行两个 CompletableFuture<T> 操作，只要其中任何一个结束，就会返回该结果并忽略其他的结果。<br>最后静态方法 allOf 和 anyOf 可以接受一组可结束的 Future 对象，并返回一个 CompletableFuture<Void> 结果，当这些 Future 对象全部结束，或者他们中的任意一个结束时，该结果就会结束。没有结果会被传播出去。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性概览(二)</title>
      <link href="/2016/03/18/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88(%E4%BA%8C)/"/>
      <url>/2016/03/18/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<h3 id="开场诗"><a href="#开场诗" class="headerlink" title="开场诗"></a>开场诗</h3><p>《丑奴儿·书博山道中壁》 宋 辛弃疾  </p><p>少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。</p><p>而今尽识愁滋味，欲说还休。欲说还休，却道天凉好个秋。</p><span id="more"></span><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><blockquote><p>Stream 是Java8中处理集合的关键抽象概念，它可以指定希望对集合进行的操作，但是将执行操作的时间交给具体的实现来决定。同时也可以使用并行的Stream APi来并行执行操作，使用多线程来计算每一段的总和与数量，再将结果汇总起来。</p></blockquote><ul><li><p>迭代器意味着特定的遍历策略，禁止来高效的并发执行</p></li><li><p>可以从 <strong>集合、数组、生成器、迭代器</strong> 中创建Stream</p></li><li><p>使用过滤器<code>filter</code>来选择元素，使用<code>map</code>来改变元素</p></li><li><p>其他改变Stream的操作包括<code>limit、distinct、sorted</code></p></li><li><p>要从Stream中获得结果，请使用<code>reduction</code>操作符，例如 <code>count、 max、 min 、findFirst、 findAny</code>。其中一些方法会返回一个<code>Optional</code>值</p></li><li><p><code>Optional</code>类型的目的是为了安全替代使用null值。要想安全的使用它，需要借助于<code>ifPresent</code>和<code>orElse</code>方法</p></li><li><p>可以收集 集合、数组、字符串、或者 map 中的Stream结果</p></li><li><p><code>Collectors</code>类中的<code>groupingBy</code>和<code>partitioningBy</code>方法允许你对Stream中的内容分组，并获取每个组的结果</p></li><li><p>Java8对原始类型 int、long、double提供了专门的Stream</p></li><li><p>当你使用 <strong>并行Stream</strong> 时，请确保不到有副作用(一致性问题)，并且 <strong>考虑放弃排序约束</strong></p></li><li><p>为了使用 Stream API，需要了解一些函数式接口</p></li><li><p>使用Stream时，大概会通过三个阶段建立一个操作流：创建一个Stream -&gt; 中间操作专拣位另一个Stream -&gt; 终止操作获取一个结果</p></li></ul><h4 id="创建stream"><a href="#创建stream" class="headerlink" title="创建stream"></a>创建stream</h4><ul><li><p>集合Collection接口中新添加的stream方法可以将任何集合转化为一个Stream<br>例如：</p><pre><code>List&lt;String&gt; list = ...Stream&lt;String&gt; stream = list.stream();</code></pre></li><li><p>数组，可以使用静态的<code>Stream.of</code>方法将它转化为一个Stream<br>Stream.of 方法接收一个可变长度的参数<br>例如：  </p><pre><code>//数组Stream&lt;String&gt; stream = Stream.of(contents.split(&quot;[\\P&#123;L&#125;]+&quot;));//变长参数列表Stream&lt;String&gt; song = Stream.of(&quot;gently&quot;,&quot;down&quot;,&quot;the&quot;,&quot;stream&quot;,&quot;hehe&quot;);</code></pre></li><li><p>通过<code>Stream.empty()</code>方法，创建一个不含任何元素的Stream<br>  <code>Stream&lt;String&gt; stream = Stream.empty()</code></p></li><li><p>Stream的 <code>generate</code>与<code>iterate</code>方法 创建无限Stream</p><ul><li><p><code>generate</code>方法接受一个参数列表(Supplier<T>接口的对象)</p><pre><code>// 创建一个包含常量值的无限StreamStream&lt;String&gt; echos = String.generate(() -&gt; &quot;Echo&quot;);// 创建一个随机数字的无限StreamStream&lt;Double&gt; randoms = Stream.generate(Math::random);</code></pre></li><li><p><code>iterate</code> 接受一个seed(种子)值，和一个函数(一个UnaryOperator<T>接口的对象)作为参数，并且对之前的值重复应用该函数</p><pre><code>//0、1、2、3、... 的无限序列Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));</code></pre></li></ul></li><li><p>还有其他可以产生Stream的方法</p><ul><li><p><code>Pattern</code> 类添加了一个<code>SplitAsStream</code>方法，能够按照正则表达式对<code>CharSequence</code>对象进行分隔，并创建Stream<br><code>Stream&lt;String&gt; words = Pattern.compile(&quot;[\\p&#123;L&#125;]++&quot;).splitAsStream(contents);</code></p></li><li><p>静态方法<code>Files.lines</code>会返回一个包涵文件中所有行的Stream。<br> Stream接口继承了AutoCloseable接口，当在某个Stream上调用close方法时，底层的文件也会被关闭，为了确保关闭文件，最好采用Java7中提供的<code>try-with-resources</code>语句：</p><pre><code> try(String&lt;String&gt; lines = Files.lines(path))&#123;   //对lines的处理 &#125;</code></pre></li></ul></li></ul><h4 id="将stream转换为另一个stream的中间操作"><a href="#将stream转换为另一个stream的中间操作" class="headerlink" title="将stream转换为另一个stream的中间操作"></a>将stream转换为另一个stream的中间操作</h4><ul><li><p>filter、map、flatMap方法</p><ul><li><p>filter 过滤器<br><code>String&lt;String&gt; longWords = words.filter(w -&gt; w.length &gt; 12);// 选择长度大于12的单词</code></p></li><li><p>map<br>对Stream中的值进行转换(相当对一个Stream<T> 实例的所有值应用函数 <code>V f(T t)</code> 返回值V 可以是任何类型，并最终返回一个<code>Stream&lt;V&gt;</code>的实例)<br><code>Stream&lt;String&gt; lowercaseWords = words.map(String::toLowerCase);</code></p></li><li><p>flatMap<br>当使用map方法时，会对流<code>Stream&lt;T&gt;</code>中的每个元素应用一个方法<code>V f(T t)</code>，并将方法的返回值收集到一个新的流<code>Stream&lt;V&gt;</code>中，然而当方法返回的不是一个具体的值，而是一个包涵多个值的流时(即f方法为<code>Stream&lt;V&gt; f(T t)</code>)，那map方法的结果就为一个包涵了多个流的流，即 <code>Stream&lt;Stream&lt;V&gt;&gt;</code>。<br>例子：  </p><pre><code> class Utils&#123;   public static Stream&lt;Character&gt; characterStream(String s)&#123;     List&lt;Character&gt; result = new ArrayList();     for (char c : s.toCharArray())&#123;       result.add(c);     &#125;     return result.stream();   &#125; &#125; // 对一个stream进行map操作    Stream&lt;Stream&lt;Character&gt;&gt; result = words.map(Utils::characterStream);// 得到的是一个Stream&lt;Stream&lt;Character&gt;&gt; 包涵了Stream的Stream // 要将Stream&lt;Stream&lt;Character&gt;&gt;展开为一个只包含字符的流，需要使用flatMap方法 Stream&lt;Character&gt; letters = words.flatMap(w -&gt; characterStream(w));</code></pre></li></ul></li><li><p>提取子流 和 组合流</p><ul><li><p><code>limit</code> 方法用于裁剪指定长度的流<br>  Stream<Double> randoms &#x3D; Stream.generate(Math::random).limit(10);</p></li><li><p><code>skip</code> 与limit正好相反，返回一个跳过指定元素的新流<br>  Stream<Double> randoms &#x3D; Stream.of(contents.split(“[\p{L}]+”)).skip(1);</p></li><li><p><code>Stream.concat</code> 静态方法 concat用语将两个流连接到一起<br>  Stream<Character> combined &#x3D; Stream.concat(Utils.characterStream(“hello”), Utils.characterStream(“world”));</p></li><li><p><code>peek</code> 方法指定一个函数，在每次获取一个元素时，对该元素调用该函数，便于调试<br>  Stream<Double> randoms &#x3D; Stream.iterate(1, p -&gt; p * 2).peek(e -&gt; System.out.println(“Fetching “ + e));</p></li></ul></li><li><p>有状态的转换<br>我所理解的有状态的转换，是 转换依赖与原始流的所有元素的值，也就是需要将原始流的值都遍历一遍。</p><ul><li><p><code>distinct</code> 根据原始流中的元素返回一个具有相同顺序、抑制了重复元素的新流。显然，这个操作需要将原始流的所有值都处理一遍。<br><code>Stream&lt;String&gt; uniqueWords = Stream.of(&quot;merrily&quot;, &quot;merrily&quot;, &quot;merrily&quot;, &quot;gently&quot;).distinct(); //只获取到一个 merrily</code></p></li><li><p><code>sorted</code> 排序<br><code>Stream&lt;String&gt; longestFirst = words.sorted(Comparator.comparing(String::length).reversed());</code></p></li></ul></li></ul><h4 id="终止操作获取一个结果"><a href="#终止操作获取一个结果" class="headerlink" title="终止操作获取一个结果"></a>终止操作获取一个结果</h4><ul><li>聚合方法<ul><li><code>count</code>  <code>max</code> <code>min</code>   </li><li><code>findFirst</code> 找到第一个并返回</li><li><code>findAny</code> 找到任何一个并返回</li><li><code>anyMatch</code><br> 接受一个Predicate<T> (即 boolean f(T t) - 一个从T 到boolean的函数对象) 参数，效果等同于  stream.filter().findAny()</li></ul></li></ul><p><strong>Optional 类型</strong><br>    Optional<T> 对象是对一个T类型对象的封装，或者表示不适任何对象。一般比指向T类型的引用更安全，因为它不会返回null(正确使用的前提下)。</p><ul><li><code>get</code>方法<br>  如果存在被封装的对象，那个get方法会返回该对象，否则会抛出一个NoSuchElementException。   </li><li><code>ifPresent</code>方法<br>  这个方法有两种使用方式：<br>    * <code>if (optionalValue.isPresent()) optionalValue.get().someMethod()</code> &#x2F;&#x2F;和判断 value !&#x3D; null 并没有太大区别<br>    * <code>optionalValue.isPresent(v -&gt; process(v));</code> &#x2F;&#x2F; 每有操作的返回值</li></ul><p>  ＊ <code>map</code> 方法<br>          <code>Optional&lt;Boolean&gt; added = optionalValue.map(results::add);</code> &#x2F;&#x2F; added 有可能是以下三种值：被封装到Optional中的true或false(根据optionalValue值是否存在)，或者是一个空的可选值  </p><ul><li><code>orElse</code> 设置一个空值的替代值<br>  <code>String result = optionalValue.orElse(&quot;&quot;);</code> &#x2F;&#x2F;封装字符串如果没有返回 空字符串””<br>  <code>String result = optionalValue.orElse(() -&gt; System.getProperty(&quot;user.dir&quot;));</code>   &#x2F;&#x2F;该函数在北需要时才会被调用</li><li><code>orElseThrow</code> 在没有值的时候抛出一个异常<br>  <code>String result = optionalValue.orElseThrow(NoSuchElementException::new);</code></li><li>创建可选值  <ul><li><code>Optional.of(result)</code></li><li><code>Optional.empty()</code></li><li><code>Optional.ofNullable(result)</code> 如果result不为null时，会返回Optional.of(result)，否则会返回Optional.empty()</li></ul></li><li>使用<code>flatMap</code> 来组合可选值函数<br>s对象如果有一个返回Optinal<T>的方法 f，并且目标类型T有一个会返回Optional<U>的方法g。这时 s.f().g() 是不可行的，因为 s.f()返回的是Optional<T>并不是T，此时可以这样操作 <code>Optional&lt;U&gt; = s.f().flatMap(T::g);</code> 如果s.f()存在则会继续调用，否则返回一个空的Optional<U>。此时Optional可以看作一个元素数为1的流，与流的flatMap作用一致。</li></ul><h4 id="聚合操作-reduce"><a href="#聚合操作-reduce" class="headerlink" title="聚合操作 reduce"></a>聚合操作 <code>reduce</code></h4><p>  当我们希望对元素求和，或者以其他方式将流中的元素组合为一个值时，可以使用聚合方法。   </p><ul><li><p>使用一个二元函数  </p><pre><code>  Stream&lt;Integer&gt; values = ...     Optional&lt;Integer&gt; sum = values.reduce((x, y) -&gt; x + y);</code></pre></li><li><p>提供标识值</p><pre><code>  Stream&lt;Integer&gt; values = ...  Optinal&lt;Integer&gt; sum = values.reduce(0, (x, y) -&gt; x + y);// 当流为空时，返回标识值 0</code></pre></li><li><p>对属性进行聚合<br>  如果我们想对流中的元素的某个属性进行聚合，比如 String 的 length() 函数得到的值：</p><pre><code>  int result = words.reduce(0,    (total, word) -&gt; total + word.length(),//累加器函数，该函数会被重复调用，形成累加值。    (total1, total2) -&gt; total1 + total2);// 当并行计算时，会形成累加值，所以要提供第二个函数，将形成的多个累加值再累加起来。</code></pre></li></ul><h4 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h4><p>当需要将Stream以聚合值之外的其它形式返回时。</p><ul><li><p>收集到数组中<br>Stream<String> words &#x3D; …<br>String[] result &#x3D; words.toArray(String[]::new);</p></li><li><p>列表<br><code>List&lt;String&gt; result = stream.collect(Collectors.toList());</code><br><code>TreeSet&lt;String&gt; result = stream.collect(Collectors.toCollection(TreeSet::new))</code> &#x2F;&#x2F;控制得到的Set类型</p></li><li><p>字符串的收集<br><code>String result = stream.collect(Collectors.joining());//将所有的字符串连接并收集</code><br><code>String result = stream.collect(Collectors.joining(&quot;, &quot;)//加分隔符)</code><br><code>String reuslt = stream.map(Object::toString).collect(Collectors.joining()); //流包含字符串以外的对象</code>  </p></li><li><p>数值的收集<br>对数值进行收集，并希望获取 总和、最大值、 最小值、平均值时，可以使用 Collectors.summarizingInt(Integer|Long|Double)</p><pre><code>IntSummaryStatistics summary = words.collect(Collectors.summarizingInt(String::length));double averageWordLength = summary.getAverage();double maxWordLength = summary.getMax();</code></pre></li><li><p>收集到Map中<br>对于一个Stream<Person>实例personStream有</p><ul><li><p>Person 的 id 作为key， name作为value</p><p><code>Map&lt;Integer, String&gt; idToName = personStream.collect(Collectors.toMap(Person::getId, Person::getName));</code></p></li><li><p>以id作为key， 元素自己作为 value</p><p><code>Map&lt;Integer, Person&gt; idToPerson = personStream.collect(Collectors.toMap(Person::getId, Function.Identity()));</code></p></li></ul></li></ul><h4 id="分组和分片"><a href="#分组和分片" class="headerlink" title="分组和分片"></a>分组和分片</h4><p><strong>以下所有直接使用方法的均视为直接静态引用了Collectors.</strong>*</p><ul><li><p>分组<br>  例子：对本地可用语言环境进行分组</p><pre><code>//获取本地可用语言环境Stream&lt;Locale&gt; localeStream = Stream.of(Locale.getAvailableLocales());//分组一：按照国家分组Map&lt;String, List&lt;Locale&gt;&gt; countryToLocale = localeStream.collect(Collectors.groupingBy(Locale::getCountry));//分组二：当分类函数是一个 Predicate&lt;T&gt;(即一个返回boolean值的函数)时，流元素会被分为两组列表，一组是函数返回true的元素，另一组是函数返回false的元素。//这种情况下，使用 Collectors.partitioningBy() 会更有效率。Map&lt;String, List&lt;Locale&gt;&gt; englishAndOtherLocales = localeStream.collect(Collectors.partitioningBy(l -&gt; l.getLanguage().equals(&quot;en&quot;)));// 三：goupingByConcurrent 方法会返回一个并发map，用于并行流时可以并发的插入值。Map&lt;String, List&lt;Locale&gt;&gt; countryToLocales = localeStream.parallel().collect(Collectors.groupingByConcurrent(Locale::getCountry));</code></pre><p>对分组后的元素进行 downstream 处理</p><ul><li><p>counting 返回所收集元素的总个数</p><pre><code>// counting 返回收集元素的总个数Map&lt;String, Long&gt; countryToLocalesCount = localeStream.collect(Collectors.groupingBy(Locale::getCountry, Collectors.counting()));</code></pre></li><li><p>summing(Integer|Long|Double) 方法接受一个函数作为参数，应用到收集的元素，并将结果求和</p><pre><code>//summing求和Map&lt;String, Integer&gt; stateToCityPopulation = cities.collect(Collectors.groupingBy(Locale::getState, Collectors.summingInt(City::getPopulation)));</code></pre></li><li><p>maxBy 和 minBy 会接受一个比较器，生成一个最大值和最小值</p><pre><code>Map&lt;String, City&gt; stateToLargestCity = cities.collect(Collectors.groupingBy(City::getState, Collectors.maxBy(Comparator.comparing(City::getPopulation))));</code></pre></li><li><p>mapping 方法会将一个函数应用到 downstream结果上，并且需要另一个收集器来处理结果。</p><pre><code>//这里，先将城市按照州进行分组，在每个州中，我们生成每个城市的名称并按照其最大长度进行聚合Map&lt;String, Optional&lt;String&gt;&gt; stateToLongestCityName = cities.collect(  groupingBy(City::getState,    mapping(City::getName,      maxBy(Comparator.comparing(String::length)))));</code></pre></li><li><p>如果 grouping 或者mapping 函数的返回类型时int、lang、或者double，可以将元素收集到一个 summary statistics对象中。</p><pre><code>Map&lt;String, IntSummaryStatistics&gt; stateToCityPopulationSummary = cities.collect(  groupingBy(City::getState,    summarizingInt(City::getPopulation))  );</code></pre></li><li><p>reducing 方法会对 downstream 元素进行一次普通的聚合操作。<br>该方法有三种形式：</p><ul><li><p>reducing(binaryOperator)</p></li><li><p>reducing(identity, binaryOperator)</p></li><li><p>reducing(identity, mapper, binaryOperator)</p><pre><code>// 按照州分组，并将城市影射(mapper)到自己的名称上，然后将他们追加起来Map&lt;String, String&gt; stateToCityNames = cities.collect(  groupingBy(City::getState,    reducing(&quot;&quot;, City::getName,    (s, t) -&gt; s.length() == 0 ? t : s + &quot;,&quot; + t))  );// 另一种实现方式Map&lt;String, String&gt; stateToCityNames = cities.collect(  groupingBy(&quot;&quot;,  mapping(City::getName,    joining(&quot;, &quot;))  ));</code></pre></li></ul></li></ul></li></ul><p>  如上，downstream收集器可以产生非常复杂的表达式。我们应该只有在为了通过<code>groupingBy</code>或<code>partitioningBy</code>来产生”downstream”map时，才使用它们。其它情况下，只需要对流直接应用map，reduce，max，或者min方法即可。</p><h4 id="原始类型流"><a href="#原始类型流" class="headerlink" title="原始类型流"></a>原始类型流</h4><p>  将整数包装成相应对象是一个很低效的做法，对于其它原始类型 double，float，short，char，byte，及boolean也是一样。为此，Stream API提供了IntStream，LongStream和DoubleStream等类型。专门用来直接存储原始类型值。<br>  <strong>如果要存储 short、char、byte、boolean类型的值，请使用 IntStream；<br>  如果要存储 float 类型的值，请使用 DoubleStream。</strong></p><ul><li><p>IntStream stream &#x3D; IntStream.of(1, 2, 3, 4, 5);</p></li><li><p>IntStream stream &#x3D; Arrays.stream(values, from, to); &#x2F;&#x2F;values是一个 int 数组</p></li><li><p>IntStream zeroToNinetyNine &#x3D; IntStream.range(0, 100);</p></li><li><p>IntStream zerToHundred &#x3D; IntStream.rangeClosed(0, 100);</p></li><li><p>IntStream codes &#x3D; stringInstance.codePoints();<br>&#x2F;&#x2F;CharSequence接口有两个方法：codePoints和chars 可以生成包含字符的Unicode代码的流，或者包涵UTF-16编码的 <em>代码单元</em> 的IntStream。</p></li><li><p>对象流转换为原始类型流: mapToInt 、mapToLong、 mapToDouble<br><code>IntStream lengths = words.mapToInt(String::length);</code></p></li><li><p>原始类型流转向对象流: boxed 方法<br><code>Stream&lt;Integer&gt; integers = IntStream.range(0, 10).boxed();</code></p></li><li><p>toArray 方法会返回一个原始类型的数组</p></li><li><p>产生Optional结果的方法会返回一个 OptionalInt、OptinalLong 或者 OptionalDouble 类型。这些类型于Optional类型相似，只是没有get方法，而是对应的getAsInt、getAsLong、getAsDouble类代替</p></li><li><p>方法 sum、average、max、min 会返回总和、平均值、最大值和最小值。在对象流中并没有这些方法</p></li><li><p>summaryStatistics 方法会产生一个 IntSummaryStatistics、LongSummaryStatistics、DoubleSummaryStatistics 对象，可以同时获得总和、平均值、最大值、最小值</p></li><li><p>Random 类现在提供了 ints、longs、doubles 这些方法，来返回包涵随机数字的原始类型流</p></li></ul><h4 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h4><p>  首先，你得有个并行流：</p><ul><li><p>Collection.parallelStream()</p></li><li><p>Stream.of(words).<code>parallel()</code>;<br>  并行流注意事项：</p></li><li><p>竞态条件 ： 你要确认传递给并行流操作的函数是线程都是安全的。</p></li><li><p>关于排序：默认情况下，从有序集合(数组或列表)，范围值，生成器 或迭代器，或者调用 Stream.sorted所产生的流都是有序的。<br>有序的流会按照原始元素的顺序进行累计，并且是完全可预测的。如果你将同一个操作运行两次，你将会得到一模一样的结果。有序并不会妨碍并行。例如，当计算stream.map(fun)时，流可以被分片为n段，每一段都会被并行处理。然后按顺序将结果组合起来。<br>当不考虑有序时，一些操作可以更有效的并行运行。调用<code>Stream.ubordered()</code>方法可以不关心排序。Stream.distinct就是一个可以从中获益的方法。对于一个有序的流，distinct会保留所有相等元素的第一个。这样就会阻碍并行，因为要处理某段元素的线程只有在之前的元素段处理完毕后，才知道自己应该丢弃哪些元素。</p></li><li><p>关于改变流底层的集合<br>由于intermediate(中间)流操作是延迟的，所以当终止操作执行时他有可能会改变集合。</p><pre><code>//正确的代码List&lt;String&gt; wordList = ...;Stream&lt;String&gt; words = wordList.stream();wordList.add(&quot;END&quot;);long n = words.distinct().count();//触发流中间操作，此时底层集合改变生效//错误的代码Stream&lt;String&gt; words = wordList.stream();words.forEach(s -&gt; if(s.length() &lt; 12) wordList.remove(s));//错误</code></pre></li></ul><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>在Stream API中使用的函数式接口</p><table><thead><tr><th align="left">函数式接口</th><th align="left">参数类型</th><th align="left">返回类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">Supplier<T></td><td align="left">无</td><td align="left">T</td><td align="left">提供一个T类型的值</td></tr><tr><td align="left">Consumer<T></td><td align="left">T</td><td align="left">void</td><td align="left">处理一个T类型的值</td></tr><tr><td align="left">BiConsumer&lt;T, U&gt;</td><td align="left">T, U</td><td align="left">void</td><td align="left">处理T类型和U类型的值</td></tr><tr><td align="left">Predicate<T></td><td align="left">T</td><td align="left">boolean</td><td align="left">一个通过给定T类型值计算Boolean值的函数</td></tr><tr><td align="left">ToIntFunction<T></td><td align="left">T</td><td align="left">int</td><td align="left">计算int 的函数</td></tr><tr><td align="left">ToLongFunction<T></td><td align="left">T</td><td align="left">long</td><td align="left">计算 long的得函数</td></tr><tr><td align="left">ToDoubleFunction<T></td><td align="left">T</td><td align="left">double</td><td align="left">计算double的得函数</td></tr><tr><td align="left">IntFunction<R></td><td align="left">int</td><td align="left">R</td><td align="left">参数为int 返回R</td></tr><tr><td align="left">LongFunction<R></td><td align="left">long</td><td align="left">R</td><td align="left">参数为long 返回R</td></tr><tr><td align="left">DoubleFunction<R></td><td align="left">double</td><td align="left">R</td><td align="left">参数为double返回R</td></tr><tr><td align="left">Function&lt;T, R&gt;</td><td align="left">T</td><td align="left">R</td><td align="left">参数为T返回R</td></tr><tr><td align="left">BiFunction&lt;T, U, R&gt;</td><td align="left">T, U</td><td align="left">R</td><td align="left">参数为T、U、返回R</td></tr><tr><td align="left">UnaryOperator<T></td><td align="left">T</td><td align="left">T</td><td align="left">对类型T进行的一元操作</td></tr><tr><td align="left">BinaryOperator<T></td><td align="left">T , T</td><td align="left">T</td><td align="left">对T类型进行的二元操作</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性概览(一)</title>
      <link href="/2016/03/10/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88(%E4%B8%80)/"/>
      <url>/2016/03/10/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%A6%82%E8%A7%88(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h3 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h3><p>Java8推出已经两年了，这本书买了也有一年多了，最近才开始看😂。Oracle官方也已经宣布不再更新Java7，同时伴随着Spring Boot的推出与不断更新，越来越多的Java应用会使用Java8。so，抓紧来学习下Java8的新特性。做一下读书笔记。</p><span id="more"></span><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><blockquote><p>lambda 表达式就是带有参数的表达式。   </p></blockquote><h4 id="lambda表达式语法"><a href="#lambda表达式语法" class="headerlink" title="lambda表达式语法"></a>lambda表达式语法</h4><p>格式：参数、箭头（-&gt;）、表达式<br><code>(args) -&gt; &#123;expression&#125;</code>   </p><p>例1：java线程的实现   </p><pre><code>// 线程的业务逻辑   class Worker implements Runnable &#123;     public void run()&#123;      doWork();     &#125;    &#125;   // 将该实例提交到一个线程池中，或者直接启动一个新的线程。  Worker w = new Worker();  new Thread(w).start();// 使用lambda，可以直接这样写  new Thread(() -&gt; doWork()).start();</code></pre><p>例2: 比较器</p><pre><code>// 一个根据字符串长度来比较的Comparator   class LengthComparator implements Comparator&lt;String&gt; &#123;    public int compare(String first, String second)&#123;         return Integer.compare(first.length(), second.length());    &#125;  &#125;  Arrays.sort(strings, new LengthComparator());  // 使用lambda，可以直接这样写  Arrays.sort(strings, (first, second) -&gt; Integer.compare(first.length(), second.length()));</code></pre><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><blockquote><p>对于<strong>只包含一个抽象方法</strong>的接口，我们<strong>可以通过lambda表达式来创建该接口的对象</strong>。这种接口被称为函数式接口。</p></blockquote><p>例如上面提到的Runnable, Comparator 都是只有一个抽象方法，可以直接通过lambda表达式来创建其实例。<br>我们可以在任意的函数式接口上标注<code>@FunctionalInterface</code>注解，这样做有两个好处。一：编译器会检查标注该注解的实体，检查它是否是只包含一个抽象方法的接口。二：在javadoc页面也会包含一条声明，说明这个接口是一个函数式接口。  </p><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><blockquote><p>有些时候，如果想要传递给其他代码的操作已经有实现的方法了。可以直接将方法传递给对方。   </p></blockquote><p>例如在按钮被点击时打印event对象：<br><code>button.setOnAction(event -&gt; System.out.println(event));</code></p><p>直接将println方法传递给setOnAction方法：<br><code>button.setOnAction(Syetem.out::println);</code>  </p><p>希望不区分大小写对字符串排序：<br><code>Arrays.sort(strings, String::compareToIgnoreCase)</code>  </p><p>如以上代码所示，<code>::</code>操作符将方法名和对象&#x2F;类的名字分隔开来。以下是三种主要使用情况：   </p><ul><li>对象::实例方法</li><li>类::静态方法</li><li>类::实例方法</li></ul><p>在乾两种情况中，方法引用等同于提供方法参数的lambda表达式。如上所述的 <code>button.setOnAction(System.out::println)//System.out.println()以action为入参，无返回值</code>。等同于<code>button.setOnAction(event -&gt; System.out.println(event))</code>。<code>Math::pow</code>等同于<code>(x,y) -&gt; Math.pow(x,y)//Math.pow()以两个数值为入参，返回一个数值</code>。在第三种情况(类::实例方法)中，第一个参数会成为之行方法的对象。例如<code>String::compareToIgnoreCase</code>等同于<code>(x,y) -&gt; x.compareToIgnoreCase(y)//第一个参数为方法的执行者，第二个参数为入参</code>。<br>此外还可以捕获方法引用中的this参数。例如：<code>this::equals</code>等同于<code>x -&gt; this.equals(x)</code>。同样可以使用super。</p><p><strong>注：lambda的1.方法业务、2.方法的入参、3.方法的反回结果 要与外部的使用场景相符。即方法的的入参、返回结果类型要相符。</strong></p><h4 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h4><blockquote><p>同方法引用类似，不同的是在构造器引用中的方法名是new。例如：Button:new 表示Button类的构造器引用。  </p></blockquote><p>例如：通过一个字符串列表构造一个stream   </p><pre><code>List&lt;String&gt; labels = ...// 编译器会从上下文推断并挑选出只带有一个String参数的Button构造器Stream&lt;Button&gt; stream = labels.stream().map(Button:new);List&lt;Button&gt; buttons = stream.collect(Collectors.toList());//直接返回一个数组Button[] buttons = labels.toArray(Button[]::new);</code></pre><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p>在lambda表达式中可以捕获所在外部环境的变量，但这些被捕获变量的值必须是final的或者有效的final值（即不会被更改的值）。<br>例：  </p><pre><code>public static void repeatMessage(String text, int count)&#123;  Runnable r = () -&gt; &#123;    while(count &gt; 0)&#123;      System.out.println(text);      count--;  // 非法的操作！！！不可以更改捕获的外部变量的值    &#125;  &#125;;&#125;</code></pre><p>另外，lambda表达式中使用this关键字时，你会引用创建该lambda表达式的方法的this参数。<br>例：</p><pre><code>public class Application&#123;  public void doWork()&#123;    Runnable r = () -&gt; &#123;      this.toString(); // 调用的是Application的toString而不是Runnable实例的toString    &#125;;  &#125;&#125;</code></pre><h4 id="接口中的默认方法"><a href="#接口中的默认方法" class="headerlink" title="接口中的默认方法"></a>接口中的默认方法</h4><p>在Java8之前，接口中添加扩展方法时，接口的所有实现类必须添加该方法的实现。这在扩展接口时是非常难以接受的。为了解决这个问题，Java设计者们在接口中新增了默认方法来解决这个问题。<br>例如有如下接口：</p><pre><code>interface Person&#123;  long getId();  //默认方法  default String getName() &#123;return &quot;John Q. Public &quot;&#125;&#125;</code></pre><p>实现Person接口的具体类必须实现getId 方法，可以选择性的实现getName方法。这样Java开发者们就可以往接口中方便的扩展实现逻辑。<br>当有另外一个接口：</p><pre><code>interface Named&#123;  default String getName() &#123;return getClass.getName  + hashCode()&#125;&#125;</code></pre><p>此时有类Student同时实现Person 和 Named接口时，必须给出 getNamed的实现。否则编译器会报错。因为编译器无法知道你选择哪个接口的实现。<br>不过可以通过这种方法指定具体的接口实现：</p><pre><code>class Student implements Person, Named &#123;  public String getName()&#123;    Person.super.getName(); // 指定Person接口中的实现  &#125;&#125;</code></pre><p>当然此时Student继承了一个父类如果也有getNamed方法那就好办了，因为在Java中，类优先于接口，接口中的相同方法会被忽略掉。</p><h4 id="接口中的静态方法"><a href="#接口中的静态方法" class="headerlink" title="接口中的静态方法"></a>接口中的静态方法</h4><p>在Java8之前，大多数接口都会配备一个工具类，例如Collection&#x2F;Collections,Path&#x2F;Paths，接口中定义规范，类中给出工具方法。Java8在接口中新增的静态方法就是酱这种工具类的静态方法直接移至接口中。<br>例如Comparator接口中新增了一个实用的方法comparing，用来接收一个键提取函数，并产生一个用来比较所提取的键的比较器。<br>例如：<code>Comparator.comparing(Student::getNamed);</code>就返回一个通过getName方法返回值进行比较的比较器。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情不知所起，一往而深</title>
      <link href="/2016/03/07/%E6%83%85%E4%B8%8D%E7%9F%A5%E6%89%80%E8%B5%B7%EF%BC%8C%E4%B8%80%E5%BE%80%E8%80%8C%E6%B7%B1/"/>
      <url>/2016/03/07/%E6%83%85%E4%B8%8D%E7%9F%A5%E6%89%80%E8%B5%B7%EF%BC%8C%E4%B8%80%E5%BE%80%E8%80%8C%E6%B7%B1/</url>
      
        <content type="html"><![CDATA[<h5 id="情不知所起，一往而深"><a href="#情不知所起，一往而深" class="headerlink" title="情不知所起，一往而深"></a>情不知所起，一往而深</h5><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=5 src="http://music.163.com/outchain/player?type=2&id=28315295&auto=1&height=66"></iframe><span id="more"></span>##### 牡丹亭 题记-汤显祖天下女子有情，宁有如杜丽娘者乎！梦其人即病，病即弥连，至手画形容，传于世而后死。死三年矣，复能溟溟莫中其所梦者而生。如丽娘者，乃可谓之有情人耳。**情不知所起，一往而深**。生而不可与死，死可以生。生而不可与死，死而不可复生者，皆非情之至也。梦中之情，何必非真？天下岂少梦中之人耶？必因落枕而成亲，待挂冠而为密者，皆形骸之论也。...]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心情 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript对象与函数</title>
      <link href="/2016/03/06/JavaScript%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0/"/>
      <url>/2016/03/06/JavaScript%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h5 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h5><p>这两天简单看了下JavaScript，做下笔记，备忘。</p><span id="more"></span><h5 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h5><blockquote><p>与Java等其他语言不同，JavaScript对象其实一个动态的属性包，即属性集合，每个属性由属性名称与属性值组成。</p></blockquote><h6 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h6><ol><li>文字形式<br>  var obj &#x3D; {key: value};</li><li>构造形式<br>  var obj &#x3D; new Object();<br>  obj.key &#x3D; value;</li></ol><p>对象的属性值可以是任意JavaScript对象，属性名称则只能是字符串。</p><h6 id="对象属性值的访问"><a href="#对象属性值的访问" class="headerlink" title="对象属性值的访问"></a>对象属性值的访问</h6><ol><li>obj.key (. 操作符，通常被称为’属性访问’)</li><li>obj[“key”] ([]操作符，通常被称为’键访问’)</li></ol><h6 id="六种基本类型"><a href="#六种基本类型" class="headerlink" title="六种基本类型"></a>六种基本类型</h6><p>JavaScript中有六中基本类型(并不是对象):</p><ol><li>string</li><li>number</li><li>boolean</li><li>null</li><li>undefined</li><li>object</li></ol><h6 id="内置对象-对象子类型"><a href="#内置对象-对象子类型" class="headerlink" title="内置对象(对象子类型)"></a>内置对象(对象子类型)</h6><ol><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp (正则表达式)</li><li>Error<blockquote><p>其实是JavaScript中的一些内置函数，可以直接使用函数的构造方式创建对象。使用原型中提供的方法。</p></blockquote></li></ol><h6 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h6><p>JavaScript对象有一个指向原型的链，当试图访问该对象的属性时，如果在该对象的属性集合中未找到，则搜索该对象的原型，如果还未搜索到，则会搜索该对象原型的原型，直到找到或者，原型的指向为null。</p><p>例子（自定义函数，并创建对象）：  </p><pre><code>function MyObj()&#123;     this.name = &quot;lili&quot;;   &#125;   MyObj.prototype.sayHello = function()&#123;console.log(&quot;hello, I&#39;m &quot; + this.name)&#125;;   var myObj = new MyObj();myObj.sayHello();myObj.name = &quot;lucy&quot;;myObj.sayHello();</code></pre><h5 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h5><p>JavaScript中，函数是一等公民，所谓一等公民，即可以声明直接调用。JavaScript中，函数也可以认为是对象。<br>可以对函数进行以下操作：</p><ol><li>赋值给变量。</li><li>指定为一个对象的属性值。</li><li>函数作为参数传递。</li><li>函数作为函数返回值返回。</li><li>使用字面值来创建函数。</li></ol><p>在HTML中创建顶层变量时，会将变量创建为window实例的属性。</p><h6 id="作为回调函数"><a href="#作为回调函数" class="headerlink" title="作为回调函数"></a>作为回调函数</h6><p><code>setTimeout(function()&#123;console.log(&quot;Hey, guy!&quot;)&#125;,3000);</code></p><h6 id="函数中的this"><a href="#函数中的this" class="headerlink" title="函数中的this"></a>函数中的this</h6><blockquote><p>JavaScript中this指向的对象（或称为执行上下文）。与函数的调用位置，调用方式有关。</p></blockquote><p>一段误解的例子:  </p><pre><code>  function foo(num)&#123;      console.log(&quot;foo: &quot; + num);      //记录foo被调用的次数      this.count++;    &#125;    foo.count = 0;    var i;    for(i = 0; i&lt;5; i++)&#123;      foo(i);    &#125;    console.log(foo.count);//0</code></pre><p>是的，输出是0.<br>再来一段：  </p><pre><code>function foo(num)&#123;    console.log(&quot;foo: &quot; + num);      //记录foo被调用的次数    this.count++;  &#125;  count = 0;  var i;  for(i = 0; i&lt;5; i++)&#123;    foo(i);  &#125;  console.log(count);//5//-----------------通过obj 调用var obj = &#123;count: 1&#125;;  foo.call(obj,1);console.log(obj.count);//2</code></pre><p>上面两个例子应该能大致解释清楚this的含义。即指向当前运行的上下文，也就是调用者。<br>当直接执行函数的时候，this则指向全局环境（默认绑定）。当在严格模式(strict mode)及”use strict”时，则不能将全局对象应用到默认绑定，因此 this会绑定到undefined。</p><h5 id="立即执行表达式"><a href="#立即执行表达式" class="headerlink" title="立即执行表达式"></a>立即执行表达式</h5><p>先上段代码 A：</p><pre><code>var foo = (function()&#123;  var secret = &quot;secret&quot;;  return&#123;    get_secret: function()&#123;      return secret;    &#125;,    new_secret: function(new_secret)&#123;      secret = new_secret;    &#125;  &#125;;&#125;());console.log(foo.get_secret());</code></pre><p>JavaScript中的立即执行表达式：  </p><p>(function(){&#x2F;<em>todo</em>&#x2F;})(); &#x2F;&#x2F;这个可以用<br>(function(){&#x2F;<em>todo</em>&#x2F;}()); &#x2F;&#x2F;推荐使用这个<br>由于函数被包含在()内，所以被解析成为表达式，而在表达式后面加上()时，将会执行该表达式。就像函数名后面加上()会执行该函数一样。<br>所以代码 A中的例子，foo其实一开始就被赋值为立即执行表达式中返回的对象：  </p><pre><code>return&#123;  get_secret: function()&#123;    return secret;  &#125;,  new_secret: function(new_secret)&#123;    secret = new_secret;  &#125;&#125;;</code></pre><p>所以拥有 get_secret, new_secret 这两个函数属性。可以调用。<br>这么做也是闭包的很好的应用。</p><h5 id="以上"><a href="#以上" class="headerlink" title="以上"></a>以上</h5><p>是这两天看的JavaScript的一个简单总结吧，知道的越多才明白自己懂得太少。<br>之所以记录下这个基础知识点，是因为还是觉得，不管各种牛逼哄哄高大上的开源框架，最终都是通过基础的语法、api来实现的，只有基础知识牢固了，才能更好的理解应用这些开源组件，才能理解各种奇技淫巧。。<br>还有很多内容是需要深入下看的，this、作用域、原型(prototype)…<br>不说了，刚打完球，现在饿的不要不要的，次饭去咯。。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet规范与Tomcat服务器</title>
      <link href="/2016/03/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%8ETomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2016/03/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%8ETomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h5><p>前几天有人问我Servlet有啥用，我们的WEB应用开发，啥时候有用到Servlet了。。我竟差点无言以对，定了定神，给他大致讲了下Servlet规范及tomcat的一次请求处理过程。然后那货点点头若有所悟的走了，恩，机智的我抓紧翻资料看有没有说错什么。<br>Servlet是Java程序员最熟悉不过的东西了，可谓是JavaEE的核心。感觉还是有必要做些笔记，时常翻阅，印象也会深刻些。下次再有人问，直接抛链接，岂（显）不（得）美（牛）哉（比）。</p><span id="more"></span><h5 id="Servlet规范概述"><a href="#Servlet规范概述" class="headerlink" title="Servlet规范概述"></a>Servlet规范概述</h5><blockquote><p><a href="https://jcp.org/en/jsr/detail?id=340">https://jcp.org/en/jsr/detail?id=340</a></p></blockquote><ol><li><p>Servlet是什么<br>Servlet 是基于 Java 技术的 web 组件,容器托管的,用于生成动态内容。像其他基于 Java 的组件技术一样, Servlet 也是基于平台无关的 Java 类格式,被编译为平台无关的字节码,可以被基于 Java 技术的 web server 动态加载并运行。容器,有时候也叫做 servlet 引擎,是 web server 为支持 servlet 功能扩展的部分。客户端 通过 Servlet 容器实现的请求&#x2F;应答模型与 Servlet 交互。  </p></li><li><p>Servlet容器<br>Servlet容器是web server或application server的一部分,提供基于请求&#x2F;响应发送模型的网络服务,解码基于 MIME 的请求,并且格式化基于 MIME 的响应。Servlet 容器也包含了管理 Servlet 生命周期。<br>Java SE 6 是构建 Servlet 容器最低的 Java 平台版本。</p></li><li><p>与其他技术比较  </p><ol><li>通常比 CGI 脚本更快,因为采用不同的处理模型。</li><li>采用标准的 API 从而支持更多的 Web Server。</li><li>拥有 Java 编程语言的所有优势,包括容易开发和平台无关。</li><li>可以访问 Java 平台提供的大量的 API。</li></ol></li></ol><h5 id="具体的API"><a href="#具体的API" class="headerlink" title="具体的API"></a>具体的API</h5><blockquote><p>servlet 有关的API都在Java EE的javax.servlet 与javax.servlet.* 包中。</p></blockquote><h6 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h6><blockquote><p>Servlet 接口是 Java Servlet API 的核心抽象。所有 Servlet 类必须直接或间接的实现该接口,或者更通常做法 是通过继承一个实现了该接口的类从而复用许多共性功能。目前有 GenericServlet 和 HttpServlet 这两个类实 现了 Servlet 接口。大多数情况下,开发者只需要继承 HttpServlet 去实现自己的 Servlet 即可。</p></blockquote><p>Servlet 基础接口定义了用于客户端请求处理的 service 方法。当有请求到达时,该方法由 servlet 容器路由到一个 servlet 实例.</p><pre><code>public interface Servlet &#123;    // 初始化    void init(ServletConfig var1) throws ServletException;    ServletConfig getServletConfig();    // 业务处理    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;    String getServletInfo();    // 终止    void destroy();&#125;</code></pre><h6 id="ServletRequest接口"><a href="#ServletRequest接口" class="headerlink" title="ServletRequest接口"></a>ServletRequest接口</h6><blockquote><p>请求对象封装了客户端请求的所有信息。在 HTTP 协议中,这些信息是从客户端发送到服务器请求的 HTTP 头部和消息体。</p></blockquote><h6 id="ServletResponse接口"><a href="#ServletResponse接口" class="headerlink" title="ServletResponse接口"></a>ServletResponse接口</h6><blockquote><p>响应(response)对象封装了从服务器返回到客户端的所有信息。在 HTTP 协议中,从服务器传输到客户端 的信息通过 HTTP 头信息或响应的消息体。</p></blockquote><h6 id="ServletContext接口"><a href="#ServletContext接口" class="headerlink" title="ServletContext接口"></a>ServletContext接口</h6><blockquote><p>ServletContext(Servlet 上下文)接口定义了 servlet 运行在的 Web 应用的视图。容器供应商负责提供 Servlet 容器的 ServletContext 接口的实现。Servlet 可以使用 ServletContext 对象记录事件,获取 URL 引用的资源, 存取当前上下文的其他 Servlet 可以访问的属性。</p></blockquote><blockquote><p>ServletContext 是 Web 服务器中已知路径的根。例如,Servlet 上下文可以从 <a href="http://www.mycorp.com/catalog">http://www.mycorp.com/catalog</a> 找出,&#x2F;catalog 请求路径称为上下文路径,所有以它开头的请求都会被路由到与 ServletContext 相关联的 Web 应用。</p></blockquote><h6 id="Filter-过滤器接口"><a href="#Filter-过滤器接口" class="headerlink" title="Filter 过滤器接口"></a>Filter 过滤器接口</h6><blockquote><p>过滤器(Filter)是 Java 组件,允许运行过程中改变进入资源的请求和资源返回的响应中的有效负载和 header 信息。</p></blockquote><blockquote><p>过滤器是一种代码重用的技术,它可以改变 HTTP 请求的内容,响应,及 header 信息。过滤器通常不产生响应或像 servlet 那样对请求作出响应,而是修改或调整到资源的请求,修改或调整来自资源的响应。</p></blockquote><h6 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h6><blockquote><p>HttpSession 记录会话信息。</p></blockquote><blockquote><p>Cookie 带有JSESSIONID跟踪会话信息。当浏览器不支持cookie时，采用URL重写来跟踪会话，如：<code>http://www.myserver.com/catalog/index.html;jsessionid=1234</code></p></blockquote><h6 id="…太多记不完…"><a href="#…太多记不完…" class="headerlink" title="…太多记不完…"></a>…太多记不完…</h6><h5 id="一个典型的事件序列："><a href="#一个典型的事件序列：" class="headerlink" title="一个典型的事件序列："></a>一个典型的事件序列：</h5><ol><li><p>客户端(如 web 浏览器)发送一个 HTTP 请求到 web 服务器；</p></li><li><p>Web 服务器接收到请求并且交给 servlet 容器处理,servlet 容器可以运行在与宿主 web 服务器同一个进 程中,也可以是同一主机的不同进程,或者位于不同的主机的 web 服务器中,对请求进行处理；  </p></li><li><p>servlet 容器根据 servlet 配置选择相应的 servlet,并使用代表请求和响应对象的参数进行调用；</p></li><li><p>servlet通过请求对象得到远程用户,HTTP POST参数和其他有关数据可能作为请求的一部分随请求一 起发送过来。Servlet 执行我们编写的任意的逻辑,然后动态产生响应内容发送回客户端。发送数据到客户 端是通过响应对象完成的；</p></li><li><p>一旦 servlet 完成请求的处理,servlet 容器必须确保响应正确的刷出,并且将控制权还给宿主 Web 服务 器。</p></li></ol><h5 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h5><blockquote><p>Java语言开发的小型轻量级应用服务器。</p></blockquote><p>直接上图：<br><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f1ix7wmgtlg20es09w3yk.gif">  </p><p><img src="http://ww1.sinaimg.cn/large/a1d44fefgw1f1ixhp1iljj20f80djwey.jpg"></p><p>Tomcat 采用了清晰的组件化架构：<br>server代表了整个tomcat服务器</p><ol><li>server中包含一到多个service提供各种服务，默认的是名称为catalina的服务</li><li>service提供请求服务首先是根据不同协议的客户端请求选择相应的Connector来进行处理的，</li><li>Connector对请求进行分析后，转而交给真正的处理引擎（Engine），即Servlet容器。</li><li>Container：可以理解为处理某类型请求的容器，处理的方式一般为把处理请求的处理器包装为Valve对象，并按一定顺序放入类型为Pipeline的管道里。Container有多种子类型：Engine、Host、Context和Wrapper，这几种子类型Container依次包含，处理不同粒度的请求。另外Container里包含一些基础服务，如Loader、Manager和Realm。</li><li>处理引擎（Engine）内部实例化一个至多个虚拟主机（Host），<br>对应不同的域名请求。</li><li>每个虚拟主机又包含多个web应用上下文环境Context，每个请求都在是相应的上下文里处理的。</li><li>上下文处理后返回响应结果给Connector，并最终返回给客户端。</li></ol><p>其中，最核心的两个组件：连接器Connector，容器Container（这个Container就是上面所讲的Servlet容器，也就相当于实现了Servlet规范的部分也是具体处理请求业务的部分）。</p><p>Connector用于接受Http请求。它的主要任务是负责接收浏览器的发过来的 tcp 连接请求，创建一个 Request 和 Response 对象分别用于和请求端交换数据，然后会产生一个线程来处理这个请求并把产生的 Request 和 Response 对象传给处理这个请求的线程，处理这个请求的线程就是 Container 组件要做的事。  </p><p>Container 是容器的父接口，所有子容器都必须实现这个接口，Container 容器的设计用的是典型的责任链的设计模式，它有四个子容器组件构成，分别是：Engine、Host、Context、Wrapper，这四个组件不是平行的，而是父子关系，Engine 包含 Host,Host 包含 Context，Context 包含 Wrapper。通常一个 Servlet class 对应一个 Wrapper，如果有多个 Servlet 就可以定义多个 Wrapper，如果有多个 Wrapper 就要定义一个更高的 Container 。</p><p>恩，说的很粗糙。更详细更好的内容Google一下有很多，还可以对照着看源码。</p><p>最后记一个设计模式。<br>组件的生命周期接口：  </p><pre><code>public interface Lifecycle &#123;  ...  public void init() throws LifecycleException;  // start  public void start() throws LifecycleException;  public void stop() throws LifecycleException;  public void destroy() throws LifecycleException;  public LifecycleState getState();  ...&#125;public abstract class LifecycleBase implements Lifecycle &#123;  ...  @Override    public final synchronized void start() throws LifecycleException &#123;      ...      try &#123;            startInternal();        &#125; catch (Throwable t) &#123;            ExceptionUtils.handleThrowable(t);            setStateInternal(LifecycleState.FAILED, null, false);            throw new LifecycleException(                    sm.getString(&quot;lifecycleBase.startFail&quot;,toString()), t);        &#125;      ...    &#125;    protected abstract void startInternal() throws LifecycleException;  ...&#125;</code></pre><p>然后各组件继承该抽象生命周期基类，实现startInternal方法，完成自己的start业务。同时需要时直接调用子组件的start方法即可。get新技能。</p><h5 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h5><p>说的很乱，太晚了，困了。。写了这么多，有的直接抄的官方文档，有的是摘抄别人的额博客(本着学习的目的，没有用于商业用途，我想大牛们不会怪我吧😄)，有的是自己之前记录的。简单梳理下，遇到具体问题，再行记录。<br>附上一篇讲的很详细的文章：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/">Tomcat 系统架构与设计模式，第 1 部分: 工作原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java技术体系梳理</title>
      <link href="/2016/02/29/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86/"/>
      <url>/2016/02/29/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h5 id="简单梳理下Java的技术体系，也就是Java官方提供的API都有哪些内容"><a href="#简单梳理下Java的技术体系，也就是Java官方提供的API都有哪些内容" class="headerlink" title="简单梳理下Java的技术体系，也就是Java官方提供的API都有哪些内容"></a>简单梳理下Java的技术体系，也就是Java官方提供的API都有哪些内容</h5><h5 id="Java-SE"><a href="#Java-SE" class="headerlink" title="Java SE"></a>Java SE</h5><blockquote><p>也就是jdk中的jvm 以及自带的api合集的具体实现   </p></blockquote><span id="more"></span><p><img src="http://ww2.sinaimg.cn/large/a1d44fefgw1f1gkcqr0d6j216u0ss10t.jpg">  </p><p>常用的的一些API及工具：</p><ol><li>java.util包：</li><li>I&#x2F;O （输入输入的API）</li><li>Concurrency（并发包）</li><li>Collections（集合库）</li><li>java.lang包：</li><li>Object （所有类的爹类）</li><li>String （无处不在的字符串）</li><li>Thread&#x2F;Runnable （线程）</li><li>java.lang.reflect（Reflection反射类库）</li><li>JVM的调试&#x2F;监控工具</li><li>jps （虚拟机进程状况工具）</li><li>jstat （虚拟机统计信息监控工具）</li><li>jinfo （Java配置信息工具）</li><li>jmap （Java内存映像工具）</li><li>jhat （虚拟机堆转储快照分析工具）</li><li>jstack （Java堆栈跟踪工具）</li><li>HSDIS （JIT生成代码反汇编）</li><li>JConsole （Java监视与管理控制台）</li><li>VisualVM （多合一的故障处理工具）</li></ol><h5 id="Java-EE"><a href="#Java-EE" class="headerlink" title="Java EE"></a>Java EE</h5><blockquote><p>是基于javase而发展出来的一套<em>规范接口</em>。由各厂商自行实现。</p></blockquote><p><img src="http://ww2.sinaimg.cn/large/a1d44fefgw1f1gkrzrg8uj20950irdh1.jpg"></p><p>这个，规范太多太广，只能有用到再慢慢学习记录。一个Servlet3.1final的规范文档就200多页😂。</p><h5 id="Java-ME"><a href="#Java-ME" class="headerlink" title="Java ME"></a>Java ME</h5><blockquote><p>是一套运行专门为嵌入式设备设计的api接口规范。比如机顶盒这种程序。</p></blockquote><p>没啥可说的。</p><h5 id="关于Android"><a href="#关于Android" class="headerlink" title="关于Android"></a>关于Android</h5><blockquote><p>是谷歌依照oracle制定的部分javase规范设计的sdk以及可用java语言调用的系统api。</p></blockquote><h5 id="JSR与JCP"><a href="#JSR与JCP" class="headerlink" title="JSR与JCP"></a>JSR与JCP</h5><ol><li>JSR<br>Java Specification Request(Java 规范请求)。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR(Java 规范请求)，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。<a href="https://jcp.org/en/jsr/overview">JSR查看地址</a></li><li>JCP<br>Java Community Process。是一个开放的国际组织，官方网址是<a href="http://jcp.org/en/home/index">http://jcp.org/en/home/index</a>，主要由Java开发者以及被授权者组成，职能是发展和更新Java技术规范、参考实现（RI）、技术兼容包（TCK）。Java技术和JCP两者的原创者都是SUN计算机公司。</li></ol><h5 id="总结下"><a href="#总结下" class="headerlink" title="总结下"></a>总结下</h5><p>所谓百变不离其宗，Java的开源组件是很多很杂，但都是使用Java提供的API，遵守Java官方相应规范进行开发的。弄清楚这些最基本的技术、规范受益匪浅。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序猿的技术栈</title>
      <link href="/2016/02/27/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
      <url>/2016/02/27/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<hr><h4 id="简单说下个人觉得关于程序员的所应该-掌握-x2F-了解-的知识吧。"><a href="#简单说下个人觉得关于程序员的所应该-掌握-x2F-了解-的知识吧。" class="headerlink" title="简单说下个人觉得关于程序员的所应该 掌握&#x2F;了解 的知识吧。"></a>简单说下个人觉得关于程序员的所应该 掌握&#x2F;了解 的知识吧。</h4><h4 id="基本功"><a href="#基本功" class="headerlink" title="基本功"></a>基本功</h4><ol><li>算法与数据结构</li><li>操作系统 Linux&#x2F;Unix</li><li>系统设计&#x2F;设计模式</li></ol><span id="more"></span><h4 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h4><ol><li>Javascript(自从有了node解释器，前后通吃了)</li><li>Css、Html</li></ol><h4 id="晋升为服务端"><a href="#晋升为服务端" class="headerlink" title="晋升为服务端"></a>晋升为服务端</h4><ol><li>C</li><li>Java&#x2F;c++</li><li>Python&#x2F;Scala&#x2F;Go</li><li>…</li></ol><h4 id="拿下数据库，成为传说中的full-stack"><a href="#拿下数据库，成为传说中的full-stack" class="headerlink" title="拿下数据库，成为传说中的full stack"></a>拿下数据库，成为传说中的full stack</h4><ol><li>mysql／oracle／db2…</li></ol><h4 id="全栈之后"><a href="#全栈之后" class="headerlink" title="全栈之后"></a>全栈之后</h4><ol><li>多关注项目需求与项目进度把控，人员配置。 努力成为项目经理。</li><li>广泛了解各种开源项目、技术，学会根据需求搭建系统，进行技术选型。 努力成为架构师。</li><li>关注用户体验，需求挖掘。 努力成为 产品经理。</li><li>直接创业当老板吧。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上，是根据自己目前工作这两年所积累的尚且浅显的知识经验总结出来的。定有很多不足的地方，还需要不断完善，留给自己做个参考吧。如果哪天觉得很牛逼了，就来看看，冷静下。</p><p>关于程序员技术成长的文章有很多，比如陈皓的<a href="http://coolshell.cn/articles/4990.html">程序员技术练级攻略</a>，萧井陌的<a href="http://zhuanlan.zhihu.com/xiao-jing-mo/19959253">编程入门指南 v1.4</a> 都是很好的文章。如果还想在技术这条路上走的更远更稳健，可以多看看，也许会有很好的感悟。</p><p>其实感觉作为程序员其实学习、成长 有些类似打怪升级。把自己不会的技术、知识 一个一个的拿下。当然每个人的状况、所处环境不一样，选择打的关卡顺序不一样而已。  </p><p>计划往往是很美好的，这个技术路线如果放在大学里去实行那是最好的了。工作中用到的技术汪汪不是自己能决定的。想学的东西也都要根据公司的需求来。要能在满足公司工作需求的基础上制定计划提升自己。或者直接去钻研自己最喜欢的那项吧。</p><p>最后，很重要的一点：撸码！撸码！撸码！ 看了再多文章博客并不能使你成为大牛，只有不断撸码、调试、重构、迭代 这条路。尤其向我这种笨笨的弱鸡。不说了，排位赛要开始了。。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2016/02/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2016/02/25/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<hr><p>一时兴起，又把博客搞起来了，之前是写了删，删了写。总觉的想写的东西都被大牛们写完了。前两天看到一个ACMer的博客，顿生敬意，因为大多数讲算法的都看不懂，我啥时候算法也能这么屌就好了，就这么突然又萌生了把blog写起来的想法，纪录下自己的一些想法，做一做学习笔记，日后看起来也许会觉得很有趣。也许也是因为最近确实心烦。就以这篇为开始吧，我会经常更的。</p><h4 id="若得心事如常诉，谁肯一生扮疏狂"><a href="#若得心事如常诉，谁肯一生扮疏狂" class="headerlink" title="若得心事如常诉，谁肯一生扮疏狂"></a>若得心事如常诉，谁肯一生扮疏狂</h4><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=60 height=5 src="http://music.163.com/outchain/player?type=2&id=610661&auto=1&height=66"></iframe><span id="more"></span>#### 反省一下<p>毕业快三年了，这三年学到了很多，貌似也丢掉了很多。想起实习的那段时间，别人都出去工作了，我还一个人每天起早背着电脑傻乎乎的跑到教室去看书，撸码，心里就一个念头，老子就要当程序员了，从没有对这条路的任何怀疑。然而现在，那种坚定逐渐消失了。选择了一条路，却不敢迈步去走，迟疑不决。大概是瞎忙了这么久，忘了自己要的是什么。<br>做事三思而后行。三思而后行。三思而后行。<br>多做事，少说话。要说等事情完成了再说（至少有个可行方案吧）。   </p><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>计算机程序最喜欢处理结构化的数据，人脑也一样，碎片化的数据不容易处理，不容易记忆。所以要尽量让自己的知识技能体系化。以后会经常做些学习笔记，将所学的纪录下来，以备以后回顾。如果有幸被别人看到获益的话，那更是值得了。当然如果被各路大神路过拍砖那也是会获益的嘛(😂)。</p><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>读书可以医愚，这是真的。和经常读书的人聊天与不读书的人聊天，会有不一样的感觉。<br>书中自有黄金屋，书中自有颜如玉。。。这是谁说的，给我站出来(😭)，告诉我黄金屋颜如玉在哪。</p><h4 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h4><p>读书是与书的作者一个人对话，看电影则是与 编剧，导演，演员等众人对话。多看些好的电影，对自己也是极好的。</p><h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><p>这就更不用说了。以后每周都去打打篮球、跑跑步吧。足球嘛。。之前说过要成为很牛逼的边锋，估计找到颜如玉也不太可能实现了。</p><h4 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h4><p>读万卷书不如行万里路，行万里路不如阅人无数。还是有些道理的，尤其在中国。领略下祖国的大好河山，适当的放松下。现在的城市太浮躁，待得久了难免人也变得的浮躁起来。</p><h4 id="涨姿势"><a href="#涨姿势" class="headerlink" title="涨姿势"></a>涨姿势</h4><p>其实就是最新的一些科研成果吧，没办法，就是对这些高大上的东西感兴趣，虽然是似懂非懂啦。比如物理学吧，我一直觉得物理是最根本的科学，探寻这个世界的真谛，这个世界是由什么组成的，这个宇宙是怎么来的，物质的运动规律，有时候研究着研究着物理学家们自己也整懵逼了。。。真的要向这些默默奉献于学术研究的科学家致敬。前阵子轰动的引力波，有空好好了解下。<br><img src="http://ww3.sinaimg.cn/large/a1d44fefgw1f1fgbogxj9j20j609rmye.jpg"></p><h4 id="脑洞"><a href="#脑洞" class="headerlink" title="脑洞"></a>脑洞</h4><p>宇宙的年龄是130亿年，地球的年龄才大概45.4亿年，宇宙无可计数的小星系，完全有可能有比我们更先进的文明存在，也许早就找到我们，为何却迟迟没有现身。。有没有想过我们的世界是虚拟的？有人（或者说另外的生物）在控制着整个所谓的宇宙，从爆炸到所有的能源耗尽，再次爆炸，不停的做着一样的实验（这个是前几天在知乎上看到的，翻了半天没找到原文）。现在人类在不停的探寻宇宙的奥秘，引力波已经被发现了，也许就快要发现我们这个虚拟世界的事实，这样的话，宇宙的控制者们也许就要开始下一轮的新实验了，所以现在终结这个命运的话，就要加快发展科技，找到回到过去的方式，回到宇宙爆炸前，把控制者们终结掉。。😄，这个脑洞好大，我自己都不敢信。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>好久没有写东西了，感觉语无伦次，不知道如何组织语言。没关系，慢慢来吧…</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
