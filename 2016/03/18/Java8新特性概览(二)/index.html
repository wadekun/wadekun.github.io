<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java,Java8," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="开场诗《丑奴儿·书博山道中壁》 宋 辛弃疾  
少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。
而今尽识愁滋味，欲说还休。欲说还休，却道天凉好个秋。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8新特性概览(二)">
<meta property="og:url" content="http://wadekun.github.io/2016/03/18/Java8新特性概览(二)/index.html">
<meta property="og:site_name" content="昆仑子的一亩三分地">
<meta property="og:description" content="开场诗《丑奴儿·书博山道中壁》 宋 辛弃疾  
少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。
而今尽识愁滋味，欲说还休。欲说还休，却道天凉好个秋。">
<meta property="og:updated_time" content="2016-03-23T14:39:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java8新特性概览(二)">
<meta name="twitter:description" content="开场诗《丑奴儿·书博山道中壁》 宋 辛弃疾  
少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。
而今尽识愁滋味，欲说还休。欲说还休，却道天凉好个秋。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Java8新特性概览(二) | 昆仑子的一亩三分地 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">昆仑子的一亩三分地</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">芝兰生于深谷，不以无人而不芳；君子修身养德，不因穷困而改志。</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'LqUZricbyKxz5zPZ4w6z','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Java8新特性概览(二)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-18T22:41:21+08:00" content="2016-03-18">
              2016-03-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/03/18/Java8新特性概览(二)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/18/Java8新特性概览(二)/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="开场诗"><a href="#开场诗" class="headerlink" title="开场诗"></a>开场诗</h3><p>《丑奴儿·书博山道中壁》 宋 辛弃疾  </p>
<p>少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。</p>
<p>而今尽识愁滋味，欲说还休。欲说还休，却道天凉好个秋。</p>
<a id="more"></a>
<h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><blockquote>
<p>Stream 是Java8中处理集合的关键抽象概念，它可以指定希望对集合进行的操作，但是将执行操作的时间交给具体的实现来决定。同时也可以使用并行的Stream APi来并行执行操作，使用多线程来计算每一段的总和与数量，再将结果汇总起来。</p>
</blockquote>
<ul>
<li>迭代器意味着特定的遍历策略，禁止来高效的并发执行</li>
<li>可以从 <strong>集合、数组、生成器、迭代器</strong> 中创建Stream</li>
<li>使用过滤器<code>filter</code>来选择元素，使用<code>map</code>来改变元素</li>
<li>其他改变Stream的操作包括<code>limit、distinct、sorted</code></li>
<li>要从Stream中获得结果，请使用<code>reduction</code>操作符，例如 <code>count、 max、 min 、findFirst、 findAny</code>。其中一些方法会返回一个<code>Optional</code>值</li>
<li><code>Optional</code>类型的目的是为了安全替代使用null值。要想安全的使用它，需要借助于<code>ifPresent</code>和<code>orElse</code>方法</li>
<li>可以收集 集合、数组、字符串、或者 map 中的Stream结果</li>
<li><code>Collectors</code>类中的<code>groupingBy</code>和<code>partitioningBy</code>方法允许你对Stream中的内容分组，并获取每个组的结果</li>
<li>Java8对原始类型 int、long、double提供了专门的Stream</li>
<li>当你使用 <strong>并行Stream</strong> 时，请确保不到有副作用(一致性问题)，并且 <strong>考虑放弃排序约束</strong></li>
<li><p>为了使用 Stream API，需要了解一些函数式接口</p>
</li>
<li><p>使用Stream时，大概会通过三个阶段建立一个操作流：创建一个Stream -&gt; 中间操作专拣位另一个Stream -&gt; 终止操作获取一个结果</p>
</li>
</ul>
<h4 id="创建stream"><a href="#创建stream" class="headerlink" title="创建stream"></a>创建stream</h4><ul>
<li><p>集合Collection接口中新添加的stream方法可以将任何集合转化为一个Stream<br>例如：</p>
<pre><code>List&lt;String&gt; list = ...
Stream&lt;String&gt; stream = list.stream();
</code></pre></li>
<li><p>数组，可以使用静态的<code>Stream.of</code>方法将它转化为一个Stream<br>Stream.of 方法接收一个可变长度的参数<br>例如：  </p>
<pre><code>//数组
Stream&lt;String&gt; stream = Stream.of(contents.split(&quot;[\\P{L}]+&quot;));
//变长参数列表
Stream&lt;String&gt; song = Stream.of(&quot;gently&quot;,&quot;down&quot;,&quot;the&quot;,&quot;stream&quot;,&quot;hehe&quot;);
</code></pre></li>
<li><p>通过<code>Stream.empty()</code>方法，创建一个不含任何元素的Stream<br>  <code>Stream&lt;String&gt; stream = Stream.empty()</code></p>
</li>
<li><p>Stream的 <code>generate</code>与<code>iterate</code>方法 创建无限Stream</p>
<ul>
<li><p><code>generate</code>方法接受一个参数列表(Supplier<t>接口的对象)</t></p>
<pre><code>// 创建一个包含常量值的无限Stream
Stream&lt;String&gt; echos = String.generate(() -&gt; &quot;Echo&quot;);
// 创建一个随机数字的无限Stream
Stream&lt;Double&gt; randoms = Stream.generate(Math::random);
</code></pre></li>
<li><p><code>iterate</code> 接受一个seed(种子)值，和一个函数(一个UnaryOperator<t>接口的对象)作为参数，并且对之前的值重复应用该函数</t></p>
<pre><code>//0、1、2、3、... 的无限序列
Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO, n -&gt; n.add(BigInteger.ONE));
</code></pre></li>
</ul>
</li>
<li><p>还有其他可以产生Stream的方法</p>
<ul>
<li><p><code>Pattern</code> 类添加了一个<code>SplitAsStream</code>方法，能够按照正则表达式对<code>CharSequence</code>对象进行分隔，并创建Stream<br><code>Stream&lt;String&gt; words = Pattern.compile(&quot;[\\p{L}]++&quot;).splitAsStream(contents);</code></p>
</li>
<li><p>静态方法<code>Files.lines</code>会返回一个包涵文件中所有行的Stream。<br> Stream接口继承了AutoCloseable接口，当在某个Stream上调用close方法时，底层的文件也会被关闭，为了确保关闭文件，最好采用Java7中提供的<code>try-with-resources</code>语句：</p>
<pre><code>try(String&lt;String&gt; lines = Files.lines(path)){
  //对lines的处理
}
</code></pre></li>
</ul>
</li>
</ul>
<h4 id="将stream转换为另一个stream的中间操作"><a href="#将stream转换为另一个stream的中间操作" class="headerlink" title="将stream转换为另一个stream的中间操作"></a>将stream转换为另一个stream的中间操作</h4><ul>
<li><p>filter、map、flatMap方法</p>
<ul>
<li><p>filter 过滤器<br><code>String&lt;String&gt; longWords = words.filter(w -&gt; w.length &gt; 12);// 选择长度大于12的单词</code></p>
</li>
<li><p>map<br>对Stream中的值进行转换(相当对一个Stream<t> 实例的所有值应用函数 <code>V f(T t)</code> 返回值V 可以是任何类型，并最终返回一个<code>Stream&lt;V&gt;</code>的实例)<br><code>Stream&lt;String&gt; lowercaseWords = words.map(String::toLowerCase);</code></t></p>
</li>
<li><p>flatMap<br>当使用map方法时，会对流<code>Stream&lt;T&gt;</code>中的每个元素应用一个方法<code>V f(T t)</code>，并将方法的返回值收集到一个新的流<code>Stream&lt;V&gt;</code>中，然而当方法返回的不是一个具体的值，而是一个包涵多个值的流时(即f方法为<code>Stream&lt;V&gt; f(T t)</code>)，那map方法的结果就为一个包涵了多个流的流，即 <code>Stream&lt;Stream&lt;V&gt;&gt;</code>。<br>例子：  </p>
<pre><code>class Utils{
  public static Stream&lt;Character&gt; characterStream(String s){
    List&lt;Character&gt; result = new ArrayList();
    for (char c : s.toCharArray()){
      result.add(c);
    }
    return result.stream();
  }
}
// 对一个stream进行map操作   
Stream&lt;Stream&lt;Character&gt;&gt; result = words.map(Utils::characterStream);// 得到的是一个Stream&lt;Stream&lt;Character&gt;&gt; 包涵了Stream的Stream

// 要将Stream&lt;Stream&lt;Character&gt;&gt;展开为一个只包含字符的流，需要使用flatMap方法
Stream&lt;Character&gt; letters = words.flatMap(w -&gt; characterStream(w));
</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>提取子流 和 组合流</p>
<ul>
<li><p><code>limit</code> 方法用于裁剪指定长度的流<br>  Stream<double> randoms = Stream.generate(Math::random).limit(10);</double></p>
</li>
<li><p><code>skip</code> 与limit正好相反，返回一个跳过指定元素的新流<br>  Stream<double> randoms = Stream.of(contents.split(“[\p{L}]+”)).skip(1);</double></p>
</li>
<li><p><code>Stream.concat</code> 静态方法 concat用语将两个流连接到一起<br>  Stream<character> combined = Stream.concat(Utils.characterStream(“hello”), Utils.characterStream(“world”));</character></p>
</li>
<li><p><code>peek</code> 方法指定一个函数，在每次获取一个元素时，对该元素调用该函数，便于调试<br>  Stream<double> randoms = Stream.iterate(1, p -&gt; p * 2).peek(e -&gt; System.out.println(“Fetching “ + e));</double></p>
</li>
</ul>
</li>
<li><p>有状态的转换<br>我所理解的有状态的转换，是 转换依赖与原始流的所有元素的值，也就是需要将原始流的值都遍历一遍。</p>
<ul>
<li><p><code>distinct</code> 根据原始流中的元素返回一个具有相同顺序、抑制了重复元素的新流。显然，这个操作需要将原始流的所有值都处理一遍。<br><code>Stream&lt;String&gt; uniqueWords = Stream.of(&quot;merrily&quot;, &quot;merrily&quot;, &quot;merrily&quot;, &quot;gently&quot;).distinct(); //只获取到一个 merrily</code></p>
</li>
<li><p><code>sorted</code> 排序<br><code>Stream&lt;String&gt; longestFirst = words.sorted(Comparator.comparing(String::length).reversed());</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="终止操作获取一个结果"><a href="#终止操作获取一个结果" class="headerlink" title="终止操作获取一个结果"></a>终止操作获取一个结果</h4><ul>
<li>聚合方法<ul>
<li><code>count</code>  <code>max</code> <code>min</code>   </li>
<li><code>findFirst</code> 找到第一个并返回</li>
<li><code>findAny</code> 找到任何一个并返回</li>
<li><code>anyMatch</code><br>接受一个Predicate<t> (即 boolean f(T t) - 一个从T 到boolean的函数对象) 参数，效果等同于  stream.filter().findAny()  </t></li>
</ul>
</li>
</ul>
<p><strong>Optional 类型</strong><br>    Optional<t> 对象是对一个T类型对象的封装，或者表示不适任何对象。一般比指向T类型的引用更安全，因为它不会返回null(正确使用的前提下)。</t></p>
<ul>
<li><code>get</code>方法   <pre><code>如果存在被封装的对象，那个get方法会返回该对象，否则会抛出一个NoSuchElementException。   
</code></pre></li>
<li><code>ifPresent</code>方法     <pre><code>这个方法有两种使用方式：  
  * `if (optionalValue.isPresent()) optionalValue.get().someMethod()` //和判断 value != null 并没有太大区别   
  * `optionalValue.isPresent(v -&gt; process(v));` // 每有操作的返回值   
</code></pre>＊ <code>map</code> 方法  <pre><code>`Optional&lt;Boolean&gt; added = optionalValue.map(results::add);` // added 有可能是以下三种值：被封装到Optional中的true或false(根据optionalValue值是否存在)，或者是一个空的可选值  
</code></pre></li>
<li><code>orElse</code> 设置一个空值的替代值   <pre><code>`String result = optionalValue.orElse(&quot;&quot;);` //封装字符串如果没有返回 空字符串&quot;&quot;   
`String result = optionalValue.orElse(() -&gt; System.getProperty(&quot;user.dir&quot;));`   //该函数在北需要时才会被调用
</code></pre></li>
<li><code>orElseThrow</code> 在没有值的时候抛出一个异常   <pre><code>`String result = optionalValue.orElseThrow(NoSuchElementException::new);`
</code></pre></li>
<li>创建可选值  <ul>
<li><code>Optional.of(result)</code></li>
<li><code>Optional.empty()</code></li>
<li><code>Optional.ofNullable(result)</code> 如果result不为null时，会返回Optional.of(result)，否则会返回Optional.empty()  </li>
</ul>
</li>
<li>使用<code>flatMap</code> 来组合可选值函数<pre><code>s对象如果有一个返回Optinal&lt;T&gt;的方法 f，并且目标类型T有一个会返回Optional&lt;U&gt;的方法g。这时 s.f().g() 是不可行的，因为 s.f()返回的是Optional&lt;T&gt;并不是T，此时可以这样操作 `Optional&lt;U&gt; = s.f().flatMap(T::g);` 如果s.f()存在则会继续调用，否则返回一个空的Optional&lt;U&gt;。此时Optional可以看作一个元素数为1的流，与流的flatMap作用一致。
</code></pre></li>
</ul>
<h4 id="聚合操作-reduce"><a href="#聚合操作-reduce" class="headerlink" title="聚合操作 reduce"></a>聚合操作 <code>reduce</code></h4><p>  当我们希望对元素求和，或者以其他方式将流中的元素组合为一个值时，可以使用聚合方法。   </p>
<ul>
<li><p>使用一个二元函数  </p>
<pre><code>Stream&lt;Integer&gt; values = ...   
Optional&lt;Integer&gt; sum = values.reduce((x, y) -&gt; x + y);
</code></pre></li>
<li><p>提供标识值</p>
<pre><code>Stream&lt;Integer&gt; values = ...
Optinal&lt;Integer&gt; sum = values.reduce(0, (x, y) -&gt; x + y);// 当流为空时，返回标识值 0
</code></pre></li>
<li><p>对属性进行聚合<br>  如果我们想对流中的元素的某个属性进行聚合，比如 String 的 length() 函数得到的值：</p>
<pre><code>int result = words.reduce(0,
  (total, word) -&gt; total + word.length(),//累加器函数，该函数会被重复调用，形成累加值。
  (total1, total2) -&gt; total1 + total2);// 当并行计算时，会形成累加值，所以要提供第二个函数，将形成的多个累加值再累加起来。
</code></pre></li>
</ul>
<h4 id="收集结果"><a href="#收集结果" class="headerlink" title="收集结果"></a>收集结果</h4><p>当需要将Stream以聚合值之外的其它形式返回时。</p>
<ul>
<li>收集到数组中<pre><code>Stream&lt;String&gt; words = ...
String[] result = words.toArray(String[]::new);
</code></pre></li>
<li>列表<br><code>List&lt;String&gt; result = stream.collect(Collectors.toList());</code><br><code>TreeSet&lt;String&gt; result = stream.collect(Collectors.toCollection(TreeSet::new))</code> //控制得到的Set类型</li>
<li>字符串的收集<br><code>String result = stream.collect(Collectors.joining());//将所有的字符串连接并收集</code><br><code>String result = stream.collect(Collectors.joining(&quot;, &quot;)//加分隔符)</code><br><code>String reuslt = stream.map(Object::toString).collect(Collectors.joining()); //流包含字符串以外的对象</code>  </li>
<li><p>数值的收集<br>对数值进行收集，并希望获取 总和、最大值、 最小值、平均值时，可以使用 Collectors.summarizingInt(Integer|Long|Double)</p>
<pre><code>IntSummaryStatistics summary = words.collect(Collectors.summarizingInt(String::length));
double averageWordLength = summary.getAverage();
double maxWordLength = summary.getMax();
</code></pre></li>
<li><p>收集到Map中<br>对于一个Stream<person>实例personStream有</person></p>
<ul>
<li><p>Person 的 id 作为key， name作为value</p>
<p><code>Map&lt;Integer, String&gt; idToName = personStream.collect(Collectors.toMap(Person::getId, Person::getName));</code></p>
</li>
<li><p>以id作为key， 元素自己作为 value</p>
<p><code>Map&lt;Integer, Person&gt; idToPerson = personStream.collect(Collectors.toMap(Person::getId, Function.Identity()));</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="分组和分片"><a href="#分组和分片" class="headerlink" title="分组和分片"></a>分组和分片</h4><p><strong>以下所有直接使用方法的均视为直接静态引用了Collectors.*</strong></p>
<ul>
<li><p>分组<br>例子：对本地可用语言环境进行分组</p>
<pre><code>//获取本地可用语言环境
Stream&lt;Locale&gt; localeStream = Stream.of(Locale.getAvailableLocales());
//分组一：按照国家分组
Map&lt;String, List&lt;Locale&gt;&gt; countryToLocale = localeStream.collect(Collectors.groupingBy(Locale::getCountry));
//分组二：当分类函数是一个 Predicate&lt;T&gt;(即一个返回boolean值的函数)时，流元素会被分为两组列表，一组是函数返回true的元素，另一组是函数返回false的元素。
//这种情况下，使用 Collectors.partitioningBy() 会更有效率。
Map&lt;String, List&lt;Locale&gt;&gt; englishAndOtherLocales = localeStream.collect(Collectors.partitioningBy(l -&gt; l.getLanguage().equals(&quot;en&quot;)));

// 三：goupingByConcurrent 方法会返回一个并发map，用于并行流时可以并发的插入值。
Map&lt;String, List&lt;Locale&gt;&gt; countryToLocales = localeStream.parallel().collect(Collectors.groupingByConcurrent(Locale::getCountry));
</code></pre><p>对分组后的元素进行 downstream 处理</p>
<ul>
<li><p>counting 返回所收集元素的总个数</p>
<pre><code>// counting 返回收集元素的总个数
Map&lt;String, Long&gt; countryToLocalesCount = localeStream.collect(Collectors.groupingBy(Locale::getCountry, Collectors.counting()));
</code></pre></li>
<li><p>summing(Integer|Long|Double) 方法接受一个函数作为参数，应用到收集的元素，并将结果求和</p>
<pre><code>//summing求和
Map&lt;String, Integer&gt; stateToCityPopulation = cities.collect(Collectors.groupingBy(Locale::getState, Collectors.summingInt(City::getPopulation)));
</code></pre></li>
<li><p>maxBy 和 minBy 会接受一个比较器，生成一个最大值和最小值</p>
<pre><code>Map&lt;String, City&gt; stateToLargestCity = cities.collect(Collectors.groupingBy(City::getState, Collectors.maxBy(Comparator.comparing(City::getPopulation))));
</code></pre></li>
<li><p>mapping 方法会将一个函数应用到 downstream结果上，并且需要另一个收集器来处理结果。</p>
<pre><code>//这里，先将城市按照州进行分组，在每个州中，我们生成每个城市的名称并按照其最大长度进行聚合
Map&lt;String, Optional&lt;String&gt;&gt; stateToLongestCityName = cities.collect(
  groupingBy(City::getState,
    mapping(City::getName,
      maxBy(Comparator.comparing(String::length)))));
</code></pre></li>
<li><p>如果 grouping 或者mapping 函数的返回类型时int、lang、或者double，可以将元素收集到一个 summary statistics对象中。</p>
<pre><code>Map&lt;String, IntSummaryStatistics&gt; stateToCityPopulationSummary = cities.collect(
  groupingBy(City::getState,
    summarizingInt(City::getPopulation))
  );
</code></pre></li>
<li><p>reducing 方法会对 downstream 元素进行一次普通的聚合操作。<br>该方法有三种形式：</p>
<ul>
<li>reducing(binaryOperator)</li>
<li>reducing(identity, binaryOperator)</li>
<li><p>reducing(identity, mapper, binaryOperator)</p>
<pre><code>// 按照州分组，并将城市影射(mapper)到自己的名称上，然后将他们追加起来
Map&lt;String, String&gt; stateToCityNames = cities.collect(
  groupingBy(City::getState,
    reducing(&quot;&quot;, City::getName,
    (s, t) -&gt; s.length() == 0 ? t : s + &quot;,&quot; + t))
  );
// 另一种实现方式
Map&lt;String, String&gt; stateToCityNames = cities.collect(
  groupingBy(&quot;&quot;,
  mapping(City::getName,
    joining(&quot;, &quot;))
  ));
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  如上，downstream收集器可以产生非常复杂的表达式。我们应该只有在为了通过<code>groupingBy</code>或<code>partitioningBy</code>来产生”downstream”map时，才使用它们。其它情况下，只需要对流直接应用map，reduce，max，或者min方法即可。</p>
<h4 id="原始类型流"><a href="#原始类型流" class="headerlink" title="原始类型流"></a>原始类型流</h4><p>  将整数包装成相应对象是一个很低效的做法，对于其它原始类型 double，float，short，char，byte，及boolean也是一样。为此，Stream API提供了IntStream，LongStream和DoubleStream等类型。专门用来直接存储原始类型值。<br>  <strong>如果要存储 short、char、byte、boolean类型的值，请使用 IntStream；<br>  如果要存储 float 类型的值，请使用 DoubleStream。</strong></p>
<ul>
<li>IntStream stream = IntStream.of(1, 2, 3, 4, 5);</li>
<li>IntStream stream = Arrays.stream(values, from, to); //values是一个 int 数组</li>
<li>IntStream zeroToNinetyNine = IntStream.range(0, 100);</li>
<li>IntStream zerToHundred = IntStream.rangeClosed(0, 100);</li>
<li>IntStream codes = stringInstance.codePoints();<br>//CharSequence接口有两个方法：codePoints和chars 可以生成包含字符的Unicode代码的流，或者包涵UTF-16编码的 <em>代码单元</em> 的IntStream。</li>
<li>对象流转换为原始类型流: mapToInt 、mapToLong、 mapToDouble<br><code>IntStream lengths = words.mapToInt(String::length);</code></li>
<li><p>原始类型流转向对象流: boxed 方法<br><code>Stream&lt;Integer&gt; integers = IntStream.range(0, 10).boxed();</code></p>
</li>
<li><p>toArray 方法会返回一个原始类型的数组</p>
</li>
<li><p>产生Optional结果的方法会返回一个 OptionalInt、OptinalLong 或者 OptionalDouble 类型。这些类型于Optional类型相似，只是没有get方法，而是对应的getAsInt、getAsLong、getAsDouble类代替</p>
</li>
<li><p>方法 sum、average、max、min 会返回总和、平均值、最大值和最小值。在对象流中并没有这些方法</p>
</li>
<li>summaryStatistics 方法会产生一个 IntSummaryStatistics、LongSummaryStatistics、DoubleSummaryStatistics 对象，可以同时获得总和、平均值、最大值、最小值</li>
<li>Random 类现在提供了 ints、longs、doubles 这些方法，来返回包涵随机数字的原始类型流</li>
</ul>
<h4 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h4><p>  首先，你得有个并行流：</p>
<ul>
<li>Collection.parallelStream()</li>
<li>Stream.of(words).<code>parallel()</code>;<br>并行流注意事项：</li>
<li>竞态条件 ： 你要确认传递给并行流操作的函数是线程都是安全的。</li>
<li>关于排序：默认情况下，从有序集合(数组或列表)，范围值，生成器 或迭代器，或者调用 Stream.sorted所产生的流都是有序的。<br>有序的流会按照原始元素的顺序进行累计，并且是完全可预测的。如果你将同一个操作运行两次，你将会得到一模一样的结果。有序并不会妨碍并行。例如，当计算stream.map(fun)时，流可以被分片为n段，每一段都会被并行处理。然后按顺序将结果组合起来。<br>当不考虑有序时，一些操作可以更有效的并行运行。调用<code>Stream.ubordered()</code>方法可以不关心排序。Stream.distinct就是一个可以从中获益的方法。对于一个有序的流，distinct会保留所有相等元素的第一个。这样就会阻碍并行，因为要处理某段元素的线程只有在之前的元素段处理完毕后，才知道自己应该丢弃哪些元素。</li>
<li><p>关于改变流底层的集合<br>由于intermediate(中间)流操作是延迟的，所以当终止操作执行时他有可能会改变集合。</p>
<pre><code>//正确的代码
List&lt;String&gt; wordList = ...;
Stream&lt;String&gt; words = wordList.stream();
wordList.add(&quot;END&quot;);
long n = words.distinct().count();//触发流中间操作，此时底层集合改变生效

//错误的代码
Stream&lt;String&gt; words = wordList.stream();
words.forEach(s -&gt; if(s.length() &lt; 12) wordList.remove(s));//错误
</code></pre></li>
</ul>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>在Stream API中使用的函数式接口</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数式接口</th>
<th style="text-align:left">参数类型</th>
<th style="text-align:left">返回类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Supplier<t></t></td>
<td style="text-align:left">无</td>
<td style="text-align:left">T</td>
<td style="text-align:left">提供一个T类型的值</td>
</tr>
<tr>
<td style="text-align:left">Consumer<t></t></td>
<td style="text-align:left">T</td>
<td style="text-align:left">void</td>
<td style="text-align:left">处理一个T类型的值</td>
</tr>
<tr>
<td style="text-align:left">BiConsumer<t, u=""></t,></td>
<td style="text-align:left">T, U</td>
<td style="text-align:left">void</td>
<td style="text-align:left">处理T类型和U类型的值</td>
</tr>
<tr>
<td style="text-align:left">Predicate<t></t></td>
<td style="text-align:left">T</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">一个通过给定T类型值计算Boolean值的函数</td>
</tr>
<tr>
<td style="text-align:left">ToIntFunction<t></t></td>
<td style="text-align:left">T</td>
<td style="text-align:left">int</td>
<td style="text-align:left">计算int 的函数</td>
</tr>
<tr>
<td style="text-align:left">ToLongFunction<t></t></td>
<td style="text-align:left">T</td>
<td style="text-align:left">long</td>
<td style="text-align:left">计算 long的得函数</td>
</tr>
<tr>
<td style="text-align:left">ToDoubleFunction<t></t></td>
<td style="text-align:left">T</td>
<td style="text-align:left">double</td>
<td style="text-align:left">计算double的得函数</td>
</tr>
<tr>
<td style="text-align:left">IntFunction<r></r></td>
<td style="text-align:left">int</td>
<td style="text-align:left">R</td>
<td style="text-align:left">参数为int 返回R</td>
</tr>
<tr>
<td style="text-align:left">LongFunction<r></r></td>
<td style="text-align:left">long</td>
<td style="text-align:left">R</td>
<td style="text-align:left">参数为long 返回R</td>
</tr>
<tr>
<td style="text-align:left">DoubleFunction<r></r></td>
<td style="text-align:left">double</td>
<td style="text-align:left">R</td>
<td style="text-align:left">参数为double返回R</td>
</tr>
<tr>
<td style="text-align:left">Function<t, r=""></t,></td>
<td style="text-align:left">T</td>
<td style="text-align:left">R</td>
<td style="text-align:left">参数为T返回R</td>
</tr>
<tr>
<td style="text-align:left">BiFunction<t, u,="" r=""></t,></td>
<td style="text-align:left">T, U</td>
<td style="text-align:left">R</td>
<td style="text-align:left">参数为T、U、返回R</td>
</tr>
<tr>
<td style="text-align:left">UnaryOperator<t></t></td>
<td style="text-align:left">T</td>
<td style="text-align:left">T</td>
<td style="text-align:left">对类型T进行的一元操作</td>
</tr>
<tr>
<td style="text-align:left">BinaryOperator<t></t></td>
<td style="text-align:left">T , T</td>
<td style="text-align:left">T</td>
<td style="text-align:left">对T类型进行的二元操作</td>
</tr>
</tbody>
</table>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag">#Java</a>
          
            <a href="/tags/Java8/" rel="tag">#Java8</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/10/Java8新特性概览(一)/" rel="next" title="Java8新特性概览(一)">
                <i class="fa fa-chevron-left"></i> Java8新特性概览(一)
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/03/23/Java8新特性概览(三)/" rel="prev" title="Java8新特性概览(三)">
                Java8新特性概览(三) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/03/18/Java8新特性概览(二)/"
           data-title="Java8新特性概览(二)" data-url="http://wadekun.github.io/2016/03/18/Java8新特性概览(二)/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/liuchuanfengtouxiang.jpg"
               alt="Jack Lang" />
          <p class="site-author-name" itemprop="name">Jack Lang</p>
          <p class="site-description motion-element" itemprop="description">芝兰生于深谷，不以无人而不芳；君子修身养德，不因穷困而改志</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#开场诗"><span class="nav-number">1.</span> <span class="nav-text">开场诗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stream"><span class="nav-number">2.</span> <span class="nav-text">stream</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建stream"><span class="nav-number">2.1.</span> <span class="nav-text">创建stream</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将stream转换为另一个stream的中间操作"><span class="nav-number">2.2.</span> <span class="nav-text">将stream转换为另一个stream的中间操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#终止操作获取一个结果"><span class="nav-number">2.3.</span> <span class="nav-text">终止操作获取一个结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#聚合操作-reduce"><span class="nav-number">2.4.</span> <span class="nav-text">聚合操作 reduce</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#收集结果"><span class="nav-number">2.5.</span> <span class="nav-text">收集结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分组和分片"><span class="nav-number">2.6.</span> <span class="nav-text">分组和分片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原始类型流"><span class="nav-number">2.7.</span> <span class="nav-text">原始类型流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并行流"><span class="nav-number">2.8.</span> <span class="nav-text">并行流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数式接口"><span class="nav-number">2.9.</span> <span class="nav-text">函数式接口</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jack Lang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"liangck"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  

  
  


</body>
</html>
